Help on class SFrame in module graphlab.data_structures.sframe:

class SFrame(__builtin__.object)
 |  A tabular, column-mutable dataframe object that can scale to big data. The
 |  data in SFrame is stored column-wise on the GraphLab Server side, and is
 |  stored on persistent storage (e.g. disk) to avoid being constrained by
 |  memory size.  Each column in an SFrame is a size-immutable
 |  :class:`~graphlab.SArray`, but SFrames are mutable in that columns can be
 |  added and subtracted with ease.  An SFrame essentially acts as an ordered
 |  dict of SArrays.
 |  
 |  Currently, we support constructing an SFrame from the following data
 |  formats:
 |  
 |  * csv file (comma separated value)
 |  * sframe directory archive (A directory where an sframe was saved
 |    previously)
 |  * general text file (with csv parsing options, See :py:meth:`read_csv()`)
 |  * a Python dictionary
 |  * pandas.DataFrame
 |  * JSON
 |  * Apache Avro
 |  * PySpark RDD
 |  
 |  and from the following sources:
 |  
 |  * your local file system
 |  * the GraphLab Server's file system
 |  * HDFS
 |  * Amazon S3
 |  * HTTP(S).
 |  
 |  Only basic examples of construction are covered here. For more information
 |  and examples, please see the `User Guide <https://dato.com/learn/user
 |  guide/index.html#Working_with_data_Tabular_data>`_, `API Translator
 |  <https://dato.com/learn/translator>`_, `How-Tos
 |  <https://dato.com/learn/how-to>`_, and data science `Gallery
 |  <https://dato.com/learn/gallery>`_.
 |  
 |  Parameters
 |  ----------
 |  data : array | pandas.DataFrame | string | dict, optional
 |      The actual interpretation of this field is dependent on the ``format``
 |      parameter. If ``data`` is an array or Pandas DataFrame, the contents are
 |      stored in the SFrame. If ``data`` is a string, it is interpreted as a
 |      file. Files can be read from local file system or urls (local://,
 |      hdfs://, s3://, http://).
 |  
 |  format : string, optional
 |      Format of the data. The default, "auto" will automatically infer the
 |      input data format. The inference rules are simple: If the data is an
 |      array or a dataframe, it is associated with 'array' and 'dataframe'
 |      respectively. If the data is a string, it is interpreted as a file, and
 |      the file extension is used to infer the file format. The explicit
 |      options are:
 |  
 |      - "auto"
 |      - "array"
 |      - "dict"
 |      - "sarray"
 |      - "dataframe"
 |      - "csv"
 |      - "tsv"
 |      - "sframe".
 |  
 |  See Also
 |  --------
 |  read_csv:
 |      Create a new SFrame from a csv file. Preferred for text and CSV formats,
 |      because it has a lot more options for controlling the parser.
 |  
 |  save : Save an SFrame for later use.
 |  
 |  Notes
 |  -----
 |  - When reading from HDFS on Linux we must guess the location of your java
 |    installation. By default, we will use the location pointed to by the
 |    JAVA_HOME environment variable.  If this is not set, we check many common
 |    installation paths. You may use two environment variables to override
 |    this behavior.  GRAPHLAB_JAVA_HOME allows you to specify a specific java
 |    installation and overrides JAVA_HOME.  GRAPHLAB_LIBJVM_DIRECTORY
 |    overrides all and expects the exact directory that your preferred
 |    libjvm.so file is located.  Use this ONLY if you'd like to use a
 |    non-standard JVM.
 |  
 |  Examples
 |  --------
 |  
 |  >>> import graphlab
 |  >>> from graphlab import SFrame
 |  
 |  **Construction**
 |  
 |  Construct an SFrame from a dataframe and transfers the dataframe object
 |  across the network.
 |  
 |  >>> df = pandas.DataFrame()
 |  >>> sf = SFrame(data=df)
 |  
 |  Construct an SFrame from a local csv file (only works for local server).
 |  
 |  >>> sf = SFrame(data='~/mydata/foo.csv')
 |  
 |  Construct an SFrame from a csv file on Amazon S3. This requires the
 |  environment variables: *AWS_ACCESS_KEY_ID* and *AWS_SECRET_ACCESS_KEY* to be
 |  set before the python session started. Alternatively, you can use
 |  :py:func:`graphlab.aws.set_credentials()` to set the credentials after
 |  python is started and :py:func:`graphlab.aws.get_credentials()` to verify
 |  these environment variables.
 |  
 |  >>> sf = SFrame(data='s3://mybucket/foo.csv')
 |  
 |  Read from HDFS using a specific java installation (environment variable
 |  only applies when using Linux)
 |  
 |  >>> import os
 |  >>> os.environ['GRAPHLAB_JAVA_HOME'] = '/my/path/to/java'
 |  >>> from graphlab import SFrame
 |  >>> sf = SFrame("hdfs://mycluster.example.com:8020/user/myname/coolfile.txt")
 |  
 |  An SFrame can be constructed from a dictionary of values or SArrays:
 |  
 |  >>> sf = gl.SFrame({'id':[1,2,3],'val':['A','B','C']})
 |  >>> sf
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  2  3   C
 |  
 |  Or equivalently:
 |  
 |  >>> ids = SArray([1,2,3])
 |  >>> vals = SArray(['A','B','C'])
 |  >>> sf = SFrame({'id':ids,'val':vals})
 |  
 |  It can also be constructed from an array of SArrays in which case column
 |  names are automatically assigned.
 |  
 |  >>> ids = SArray([1,2,3])
 |  >>> vals = SArray(['A','B','C'])
 |  >>> sf = SFrame([ids, vals])
 |  >>> sf
 |  Columns:
 |      X1 int
 |      X2 str
 |  Rows: 3
 |  Data:
 |     X1  X2
 |  0  1   A
 |  1  2   B
 |  2  3   C
 |  
 |  If the SFrame is constructed from a list of values, an SFrame of a single
 |  column is constructed.
 |  
 |  >>> sf = SFrame([1,2,3])
 |  >>> sf
 |  Columns:
 |      X1 int
 |  Rows: 3
 |  Data:
 |     X1
 |  0  1
 |  1  2
 |  2  3
 |  
 |  **Parsing**
 |  
 |  The :py:func:`graphlab.SFrame.read_csv()` is quite powerful and, can be
 |  used to import a variety of row-based formats.
 |  
 |  First, some simple cases:
 |  
 |  >>> !cat ratings.csv
 |  user_id,movie_id,rating
 |  10210,1,1
 |  10213,2,5
 |  10217,2,2
 |  10102,1,3
 |  10109,3,4
 |  10117,5,2
 |  10122,2,4
 |  10114,1,5
 |  10125,1,1
 |  >>> gl.SFrame.read_csv('ratings.csv')
 |  Columns:
 |    user_id   int
 |    movie_id  int
 |    rating    int
 |  Rows: 9
 |  Data:
 |  +---------+----------+--------+
 |  | user_id | movie_id | rating |
 |  +---------+----------+--------+
 |  |  10210  |    1     |   1    |
 |  |  10213  |    2     |   5    |
 |  |  10217  |    2     |   2    |
 |  |  10102  |    1     |   3    |
 |  |  10109  |    3     |   4    |
 |  |  10117  |    5     |   2    |
 |  |  10122  |    2     |   4    |
 |  |  10114  |    1     |   5    |
 |  |  10125  |    1     |   1    |
 |  +---------+----------+--------+
 |  [9 rows x 3 columns]
 |  
 |  
 |  Delimiters can be specified, if "," is not the delimiter, for instance
 |  space ' ' in this case. Only single character delimiters are supported.
 |  
 |  >>> !cat ratings.csv
 |  user_id movie_id rating
 |  10210 1 1
 |  10213 2 5
 |  10217 2 2
 |  10102 1 3
 |  10109 3 4
 |  10117 5 2
 |  10122 2 4
 |  10114 1 5
 |  10125 1 1
 |  >>> gl.SFrame.read_csv('ratings.csv', delimiter=' ')
 |  
 |  By default, "NA" or a missing element are interpreted as missing values.
 |  
 |  >>> !cat ratings2.csv
 |  user,movie,rating
 |  "tom",,1
 |  harry,5,
 |  jack,2,2
 |  bill,,
 |  >>> gl.SFrame.read_csv('ratings2.csv')
 |  Columns:
 |    user  str
 |    movie int
 |    rating    int
 |  Rows: 4
 |  Data:
 |  +---------+-------+--------+
 |  |   user  | movie | rating |
 |  +---------+-------+--------+
 |  |   tom   |  None |   1    |
 |  |  harry  |   5   |  None  |
 |  |   jack  |   2   |   2    |
 |  | missing |  None |  None  |
 |  +---------+-------+--------+
 |  [4 rows x 3 columns]
 |  
 |  Furthermore due to the dictionary types and list types, can handle parsing
 |  of JSON-like formats.
 |  
 |  >>> !cat ratings3.csv
 |  business, categories, ratings
 |  "Restaurant 1", [1 4 9 10], {"funny":5, "cool":2}
 |  "Restaurant 2", [], {"happy":2, "sad":2}
 |  "Restaurant 3", [2, 11, 12], {}
 |  >>> gl.SFrame.read_csv('ratings3.csv')
 |  Columns:
 |  business    str
 |  categories  array
 |  ratings dict
 |  Rows: 3
 |  Data:
 |  +--------------+--------------------------------+-------------------------+
 |  |   business   |           categories           |         ratings         |
 |  +--------------+--------------------------------+-------------------------+
 |  | Restaurant 1 | array('d', [1.0, 4.0, 9.0, ... | {'funny': 5, 'cool': 2} |
 |  | Restaurant 2 |           array('d')           |  {'sad': 2, 'happy': 2} |
 |  | Restaurant 3 | array('d', [2.0, 11.0, 12.0])  |            {}           |
 |  +--------------+--------------------------------+-------------------------+
 |  [3 rows x 3 columns]
 |  
 |  The list and dictionary parsers are quite flexible and can absorb a
 |  variety of purely formatted inputs. Also, note that the list and dictionary
 |  types are recursive, allowing for arbitrary values to be contained.
 |  
 |  All these are valid lists:
 |  
 |  >>> !cat interesting_lists.csv
 |  list
 |  []
 |  [1,2,3]
 |  [1;2,3]
 |  [1 2 3]
 |  [{a:b}]
 |  ["c",d, e]
 |  [[a]]
 |  >>> gl.SFrame.read_csv('interesting_lists.csv')
 |  Columns:
 |    list  list
 |  Rows: 7
 |  Data:
 |  +-----------------+
 |  |       list      |
 |  +-----------------+
 |  |        []       |
 |  |    [1, 2, 3]    |
 |  |    [1, 2, 3]    |
 |  |    [1, 2, 3]    |
 |  |   [{'a': 'b'}]  |
 |  | ['c', 'd', 'e'] |
 |  |     [['a']]     |
 |  +-----------------+
 |  [7 rows x 1 columns]
 |  
 |  All these are valid dicts:
 |  
 |  >>> !cat interesting_dicts.csv
 |  dict
 |  {"classic":1,"dict":1}
 |  {space:1 seperated:1}
 |  {emptyvalue:}
 |  {}
 |  {:}
 |  {recursive1:[{a:b}]}
 |  {:[{:[a]}]}
 |  >>> gl.SFrame.read_csv('interesting_dicts.csv')
 |  Columns:
 |    dict  dict
 |  Rows: 7
 |  Data:
 |  +------------------------------+
 |  |             dict             |
 |  +------------------------------+
 |  |  {'dict': 1, 'classic': 1}   |
 |  | {'seperated': 1, 'space': 1} |
 |  |     {'emptyvalue': None}     |
 |  |              {}              |
 |  |         {None: None}         |
 |  | {'recursive1': [{'a': 'b'}]} |
 |  | {None: [{None: array('d')}]} |
 |  +------------------------------+
 |  [7 rows x 1 columns]
 |  
 |  **Saving**
 |  
 |  Save and load the sframe in native format.
 |  
 |  >>> sf.save('mysframedir')
 |  >>> sf2 = graphlab.load_sframe('mysframedir')
 |  
 |  **Column Manipulation**
 |  
 |  An SFrame is composed of a collection of columns of SArrays, and individual
 |  SArrays can be extracted easily. For instance given an SFrame:
 |  
 |  >>> sf = SFrame({'id':[1,2,3],'val':['A','B','C']})
 |  >>> sf
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  2  3   C
 |  
 |  The "id" column can be extracted using:
 |  
 |  >>> sf["id"]
 |  dtype: int
 |  Rows: 3
 |  [1, 2, 3]
 |  
 |  And can be deleted using:
 |  
 |  >>> del sf["id"]
 |  
 |  Multiple columns can be selected by passing a list of column names:
 |  
 |  >>> sf = SFrame({'id':[1,2,3],'val':['A','B','C'],'val2':[5,6,7]})
 |  >>> sf
 |  Columns:
 |      id   int
 |      val  str
 |      val2 int
 |  Rows: 3
 |  Data:
 |     id  val val2
 |  0  1   A   5
 |  1  2   B   6
 |  2  3   C   7
 |  >>> sf2 = sf[['id','val']]
 |  >>> sf2
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  2  3   C
 |  
 |  You can also select columns using types or a list of types:
 |  
 |  >>> sf2 = sf[int]
 |  >>> sf2
 |  Columns:
 |      id   int
 |      val2 int
 |  Rows: 3
 |  Data:
 |     id  val2
 |  0  1   5
 |  1  2   6
 |  2  3   7
 |  
 |  Or a mix of types and names:
 |  
 |  >>> sf2 = sf[['id', str]]
 |  >>> sf2
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  2  3   C
 |  
 |  
 |  The same mechanism can be used to re-order columns:
 |  
 |  >>> sf = SFrame({'id':[1,2,3],'val':['A','B','C']})
 |  >>> sf
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  2  3   C
 |  >>> sf[['val','id']]
 |  >>> sf
 |  Columns:
 |      val str
 |      id  int
 |  Rows: 3
 |  Data:
 |     val id
 |  0  A   1
 |  1  B   2
 |  2  C   3
 |  
 |  **Element Access and Slicing**
 |  
 |  SFrames can be accessed by integer keys just like a regular python list.
 |  Such operations may not be fast on large datasets so looping over an SFrame
 |  should be avoided.
 |  
 |  >>> sf = SFrame({'id':[1,2,3],'val':['A','B','C']})
 |  >>> sf[0]
 |  {'id': 1, 'val': 'A'}
 |  >>> sf[2]
 |  {'id': 3, 'val': 'C'}
 |  >>> sf[5]
 |  IndexError: SFrame index out of range
 |  
 |  Negative indices can be used to access elements from the tail of the array
 |  
 |  >>> sf[-1] # returns the last element
 |  {'id': 3, 'val': 'C'}
 |  >>> sf[-2] # returns the second to last element
 |  {'id': 2, 'val': 'B'}
 |  
 |  The SFrame also supports the full range of python slicing operators:
 |  
 |  >>> sf[1000:] # Returns an SFrame containing rows 1000 to the end
 |  >>> sf[:1000] # Returns an SFrame containing rows 0 to row 999 inclusive
 |  >>> sf[0:1000:2] # Returns an SFrame containing rows 0 to row 1000 in steps of 2
 |  >>> sf[-100:] # Returns an SFrame containing last 100 rows
 |  >>> sf[-100:len(sf):2] # Returns an SFrame containing last 100 rows in steps of 2
 |  
 |  **Logical Filter**
 |  
 |  An SFrame can be filtered using
 |  
 |  >>> sframe[binary_filter]
 |  
 |  where sframe is an SFrame and binary_filter is an SArray of the same length.
 |  The result is a new SFrame which contains only rows of the SFrame where its
 |  matching row in the binary_filter is non zero.
 |  
 |  This permits the use of boolean operators that can be used to perform
 |  logical filtering operations. For instance, given an SFrame
 |  
 |  >>> sf
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  2  3   C
 |  
 |  >>> sf[(sf['id'] >= 1) & (sf['id'] <= 2)]
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  
 |  See :class:`~graphlab.SArray` for more details on the use of the logical
 |  filter.
 |  
 |  This can also be used more generally to provide filtering capability which
 |  is otherwise not expressible with simple boolean functions. For instance:
 |  
 |  >>> sf[sf['id'].apply(lambda x: math.log(x) <= 1)]
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  
 |  Or alternatively:
 |  
 |  >>> sf[sf.apply(lambda x: math.log(x['id']) <= 1)]
 |  
 |          Create an SFrame from a Python dictionary.
 |  
 |  >>> from graphlab import SFrame
 |  >>> sf = SFrame({'id':[1,2,3], 'val':['A','B','C']})
 |  >>> sf
 |  Columns:
 |      id  int
 |      val str
 |  Rows: 3
 |  Data:
 |     id  val
 |  0  1   A
 |  1  2   B
 |  2  3   C
 |  
 |  Methods defined here:
 |  
 |  __copy__(self)
 |      Returns a shallow copy of the sframe.
 |  
 |  __delitem__(self, key)
 |      Wrapper around remove_column.
 |  
 |  __eq__(self, other)
 |  
 |  __get_column_description__(self)
 |  
 |  __get_pretty_tables__(self, wrap_text=False, max_row_width=80, max_column_width=30, max_columns=20, max_rows_to_display=60)
 |      Returns a list of pretty print tables representing the current SFrame.
 |      If the number of columns is larger than max_columns, the last pretty
 |      table will contain an extra column of "...".
 |      Parameters
 |      ----------
 |      wrap_text : bool, optional
 |      max_row_width : int, optional
 |          Max number of characters per table.
 |      max_column_width : int, optional
 |          Max number of characters per column.
 |      max_columns : int, optional
 |          Max number of columns per table.
 |      max_rows_to_display : int, optional
 |          Max number of rows to display.
 |      Returns
 |      -------
 |      out : list[PrettyTable]
 |  
 |  __getitem__(self, key)
 |      This method does things based on the type of `key`.
 |      
 |      If `key` is:
 |          * str
 |              selects column with name 'key'
 |          * type
 |              selects all columns with types matching the type
 |          * list of str or type
 |              selects all columns with names or type in the list
 |          * SArray
 |              Performs a logical filter.  Expects given SArray to be the same
 |              length as all columns in current SFrame.  Every row
 |              corresponding with an entry in the given SArray that is
 |              equivalent to False is filtered from the result.
 |          * int
 |              Returns a single row of the SFrame (the `key`th one) as a dictionary.
 |          * slice
 |              Returns an SFrame including only the sliced rows.
 |  
 |  __has_size__(self)
 |      Returns whether or not the size of the SFrame is known.
 |  
 |  __init__(self, data=None, format='auto', _proxy=None)
 |      __init__(data=list(), format='auto')
 |      Construct a new SFrame from a url or a pandas.DataFrame.
 |  
 |  __is_materialized__(self)
 |      Returns whether or not the SFrame has been materialized.
 |  
 |  __iter__(self)
 |      Provides an iterator to the rows of the SFrame.
 |  
 |  __len__(self)
 |      Returns the number of rows of the sframe.
 |  
 |  __materialize__(self)
 |      For an SFrame that is lazily evaluated, force the persistence of the
 |      SFrame to disk, committing all lazy evaluated operations.
 |  
 |  __ne__(self, other)
 |  
 |  __nonzero__(self)
 |      Returns true if the frame is not empty.
 |  
 |  __query_plan_str__(self)
 |      Returns the query plan as a dot graph string
 |  
 |  __repr__(self)
 |      Returns a string description of the frame
 |  
 |  __setitem__(self, key, value)
 |      A wrapper around add_column(s).  Key can be either a list or a str.  If
 |      value is an SArray, it is added to the SFrame as a column.  If it is a
 |      constant value (int, str, or float), then a column is created where
 |      every entry is equal to the constant value.  Existing columns can also
 |      be replaced using this wrapper.
 |  
 |  __str__(self, num_rows=10, footer=True)
 |      Returns a string containing the first 10 elements of the frame, along
 |      with a description of the frame.
 |  
 |  __str_impl__(self, num_rows=10, footer=True)
 |      Returns a string containing the first 10 elements of the frame, along
 |      with a description of the frame.
 |  
 |  add_column(self, data, name='')
 |      Add a column to this SFrame. The number of elements in the data given
 |      must match the length of every other column of the SFrame. This
 |      operation modifies the current SFrame in place and returns self. If no
 |      name is given, a default name is chosen.
 |      
 |      Parameters
 |      ----------
 |      data : SArray
 |          The 'column' of data to add.
 |      
 |      name : string, optional
 |          The name of the column. If no name is given, a default name is
 |          chosen.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The current SFrame.
 |      
 |      See Also
 |      --------
 |      add_columns
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id': [1, 2, 3], 'val': ['A', 'B', 'C']})
 |      >>> sa = graphlab.SArray(['cat', 'dog', 'fossa'])
 |      >>> # This line is equivalant to `sf['species'] = sa`
 |      >>> sf.add_column(sa, name='species')
 |      >>> sf
 |      +----+-----+---------+
 |      | id | val | species |
 |      +----+-----+---------+
 |      | 1  |  A  |   cat   |
 |      | 2  |  B  |   dog   |
 |      | 3  |  C  |  fossa  |
 |      +----+-----+---------+
 |      [3 rows x 3 columns]
 |  
 |  add_columns(self, data, namelist=None)
 |      Adds multiple columns to this SFrame. The number of elements in all
 |      columns must match the length of every other column of the SFrame. This
 |      operation modifies the current SFrame in place and returns self.
 |      
 |      Parameters
 |      ----------
 |      data : list[SArray] or SFrame
 |          The columns to add.
 |      
 |      namelist : list of string, optional
 |          A list of column names. All names must be specified. ``namelist`` is
 |          ignored if data is an SFrame.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The current SFrame.
 |      
 |      See Also
 |      --------
 |      add_column
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id': [1, 2, 3], 'val': ['A', 'B', 'C']})
 |      >>> sf2 = graphlab.SFrame({'species': ['cat', 'dog', 'fossa'],
 |      ...                        'age': [3, 5, 9]})
 |      >>> sf.add_columns(sf2)
 |      >>> sf
 |      +----+-----+-----+---------+
 |      | id | val | age | species |
 |      +----+-----+-----+---------+
 |      | 1  |  A  |  3  |   cat   |
 |      | 2  |  B  |  5  |   dog   |
 |      | 3  |  C  |  9  |  fossa  |
 |      +----+-----+-----+---------+
 |      [3 rows x 4 columns]
 |  
 |  add_row_number(self, column_name='id', start=0)
 |      Returns a new SFrame with a new column that numbers each row
 |      sequentially. By default the count starts at 0, but this can be changed
 |      to a positive or negative number.  The new column will be named with
 |      the given column name.  An error will be raised if the given column
 |      name already exists in the SFrame.
 |      
 |      Parameters
 |      ----------
 |      column_name : str, optional
 |          The name of the new column that will hold the row numbers.
 |      
 |      start : int, optional
 |          The number used to start the row number count.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The new SFrame with a column name
 |      
 |      Notes
 |      -----
 |      The range of numbers is constrained by a signed 64-bit integer, so
 |      beware of overflow if you think the results in the row number column
 |      will be greater than 9 quintillion.
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'a': [1, None, None], 'b': ['a', 'b', None]})
 |      >>> sf.add_row_number()
 |      +----+------+------+
 |      | id |  a   |  b   |
 |      +----+------+------+
 |      | 0  |  1   |  a   |
 |      | 1  | None |  b   |
 |      | 2  | None | None |
 |      +----+------+------+
 |      [3 rows x 3 columns]
 |  
 |  append(self, other)
 |      Add the rows of an SFrame to the end of this SFrame.
 |      
 |      Both SFrames must have the same set of columns with the same column
 |      names and column types.
 |      
 |      Parameters
 |      ----------
 |      other : SFrame
 |          Another SFrame whose rows are appended to the current SFrame.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The result SFrame from the append operation.
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id': [4, 6, 8], 'val': ['D', 'F', 'H']})
 |      >>> sf2 = graphlab.SFrame({'id': [1, 2, 3], 'val': ['A', 'B', 'C']})
 |      >>> sf = sf.append(sf2)
 |      >>> sf
 |      +----+-----+
 |      | id | val |
 |      +----+-----+
 |      | 4  |  D  |
 |      | 6  |  F  |
 |      | 8  |  H  |
 |      | 1  |  A  |
 |      | 2  |  B  |
 |      | 3  |  C  |
 |      +----+-----+
 |      [6 rows x 2 columns]
 |  
 |  apply(self, fn, dtype=None, seed=None)
 |      Transform each row to an :class:`~graphlab.SArray` according to a
 |      specified function. Returns a new SArray of ``dtype`` where each element
 |      in this SArray is transformed by `fn(x)` where `x` is a single row in
 |      the sframe represented as a dictionary.  The ``fn`` should return
 |      exactly one value which can be cast into type ``dtype``. If ``dtype`` is
 |      not specified, the first 100 rows of the SFrame are used to make a guess
 |      of the target data type.
 |      
 |      Parameters
 |      ----------
 |      fn : function
 |          The function to transform each row of the SFrame. The return
 |          type should be convertible to `dtype` if `dtype` is not None.
 |          This can also be a toolkit extension function which is compiled
 |          as a native shared library using SDK.
 |      
 |      dtype : dtype, optional
 |          The dtype of the new SArray. If None, the first 100
 |          elements of the array are used to guess the target
 |          data type.
 |      
 |      seed : int, optional
 |          Used as the seed if a random number generator is included in `fn`.
 |      
 |      Returns
 |      -------
 |      out : SArray
 |          The SArray transformed by fn.  Each element of the SArray is of
 |          type ``dtype``
 |      
 |      Examples
 |      --------
 |      Concatenate strings from several columns:
 |      
 |      >>> sf = graphlab.SFrame({'user_id': [1, 2, 3], 'movie_id': [3, 3, 6],
 |                                'rating': [4, 5, 1]})
 |      >>> sf.apply(lambda x: str(x['user_id']) + str(x['movie_id']) + str(x['rating']))
 |      dtype: str
 |      Rows: 3
 |      ['134', '235', '361']
 |      
 |      Using native toolkit extension function:
 |      
 |      .. code-block:: c++
 |      
 |          #include <graphlab/sdk/toolkit_function_macros.hpp>
 |          double mean(const std::map<flexible_type, flexible_type>& dict) {
 |            double sum = 0.0;
 |            for (const auto& kv: dict) sum += (double)kv.second;
 |            return sum / dict.size();
 |          }
 |      
 |          BEGIN_FUNCTION_REGISTRATION
 |          REGISTER_FUNCTION(mean, "row");
 |          END_FUNCTION_REGISTRATION
 |      
 |      compiled into example.so
 |      
 |      >>> import example
 |      
 |      >>> sf = graphlab.SFrame({'x0': [1, 2, 3], 'x1': [2, 3, 1],
 |      ...                       'x2': [3, 1, 2]})
 |      >>> sf.apply(example.mean)
 |      dtype: float
 |      Rows: 3
 |      [2.0,2.0,2.0]
 |  
 |  column_names(self)
 |      The name of each column in the SFrame.
 |      
 |      Returns
 |      -------
 |      out : list[string]
 |          Column names of the SFrame.
 |      
 |      See Also
 |      --------
 |      rename
 |  
 |  column_types(self)
 |      The type of each column in the SFrame.
 |      
 |      Returns
 |      -------
 |      out : list[type]
 |          Column types of the SFrame.
 |      
 |      See Also
 |      --------
 |      dtype
 |  
 |  copy(self)
 |      Returns a shallow copy of the sframe.
 |  
 |  dropna(self, columns=None, how='any')
 |      Remove missing values from an SFrame. A missing value is either ``None``
 |      or ``NaN``.  If ``how`` is 'any', a row will be removed if any of the
 |      columns in the ``columns`` parameter contains at least one missing
 |      value.  If ``how`` is 'all', a row will be removed if all of the columns
 |      in the ``columns`` parameter are missing values.
 |      
 |      If the ``columns`` parameter is not specified, the default is to
 |      consider all columns when searching for missing values.
 |      
 |      Parameters
 |      ----------
 |      columns : list or str, optional
 |          The columns to use when looking for missing values. By default, all
 |          columns are used.
 |      
 |      how : {'any', 'all'}, optional
 |          Specifies whether a row should be dropped if at least one column
 |          has missing values, or if all columns have missing values.  'any' is
 |          default.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          SFrame with missing values removed (according to the given rules).
 |      
 |      See Also
 |      --------
 |      dropna_split :  Drops missing rows from the SFrame and returns them.
 |      
 |      Examples
 |      --------
 |      Drop all missing values.
 |      
 |      >>> sf = graphlab.SFrame({'a': [1, None, None], 'b': ['a', 'b', None]})
 |      >>> sf.dropna()
 |      +---+---+
 |      | a | b |
 |      +---+---+
 |      | 1 | a |
 |      +---+---+
 |      [1 rows x 2 columns]
 |      
 |      Drop rows where every value is missing.
 |      
 |      >>> sf.dropna(any="all")
 |      +------+---+
 |      |  a   | b |
 |      +------+---+
 |      |  1   | a |
 |      | None | b |
 |      +------+---+
 |      [2 rows x 2 columns]
 |      
 |      Drop rows where column 'a' has a missing value.
 |      
 |      >>> sf.dropna('a', any="all")
 |      +---+---+
 |      | a | b |
 |      +---+---+
 |      | 1 | a |
 |      +---+---+
 |      [1 rows x 2 columns]
 |  
 |  dropna_split(self, columns=None, how='any')
 |      Split rows with missing values from this SFrame. This function has the
 |      same functionality as :py:func:`~graphlab.SFrame.dropna`, but returns a
 |      tuple of two SFrames.  The first item is the expected output from
 |      :py:func:`~graphlab.SFrame.dropna`, and the second item contains all the
 |      rows filtered out by the `dropna` algorithm.
 |      
 |      Parameters
 |      ----------
 |      columns : list or str, optional
 |          The columns to use when looking for missing values. By default, all
 |          columns are used.
 |      
 |      how : {'any', 'all'}, optional
 |          Specifies whether a row should be dropped if at least one column
 |          has missing values, or if all columns have missing values.  'any' is
 |          default.
 |      
 |      Returns
 |      -------
 |      out : (SFrame, SFrame)
 |          (SFrame with missing values removed,
 |           SFrame with the removed missing values)
 |      
 |      See Also
 |      --------
 |      dropna
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'a': [1, None, None], 'b': ['a', 'b', None]})
 |      >>> good, bad = sf.dropna_split()
 |      >>> good
 |      +---+---+
 |      | a | b |
 |      +---+---+
 |      | 1 | a |
 |      +---+---+
 |      [1 rows x 2 columns]
 |      
 |      >>> bad
 |      +------+------+
 |      |  a   |  b   |
 |      +------+------+
 |      | None |  b   |
 |      | None | None |
 |      +------+------+
 |      [2 rows x 2 columns]
 |  
 |  dtype(self)
 |      The type of each column.
 |      
 |      Returns
 |      -------
 |      out : list[type]
 |          Column types of the SFrame.
 |      
 |      See Also
 |      --------
 |      column_types
 |  
 |  export_csv(self, filename, delimiter=',', line_terminator='\n', header=True, quote_level=2, double_quote=True, escape_char=r'\', quote_char='"', na_rep='', file_header='', file_footer='', line_prefix='', _no_prefix_on_first_value=False, **kwargs)
 |      Writes an SFrame to a CSV file.
 |      
 |      Parameters
 |      ----------
 |      filename : string
 |          The location to save the CSV.
 |      
 |      delimiter : string, optional
 |          This describes the delimiter used for writing csv files.
 |      
 |      line_terminator: string, optional
 |          The newline character
 |      
 |      header : bool, optional
 |          If true, the column names are emitted as a header.
 |      
 |      quote_level: csv.QUOTE_ALL | csv.QUOTE_NONE | csv.QUOTE_NONNUMERIC, optional
 |          The quoting level. If csv.QUOTE_ALL, every field is quoted.
 |          if csv.quote_NONE, no field is quoted. If csv.QUOTE_NONNUMERIC, only
 |          non-numeric fileds are quoted. csv.QUOTE_MINIMAL is interpreted as
 |          csv.QUOTE_NONNUMERIC.
 |      
 |      double_quote : bool, optional
 |          If True, quotes are escaped as two consecutive quotes
 |      
 |      escape_char : string, optional
 |          Character which begins a C escape sequence
 |      
 |      quote_char: string, optional
 |          Character used to quote fields
 |      
 |      na_rep: string, optional
 |          The value used to denote a missing value.
 |      
 |      file_header: string, optional
 |          A string printed to the start of the file
 |      
 |      file_footer: string, optional
 |          A string printed to the end of the file
 |      
 |      line_prefix: string, optional
 |          A string printed at the start of each value line
 |  
 |  export_json(self, filename, orient='records')
 |      Writes an SFrame to a CSV file.
 |      
 |      Parameters
 |      ----------
 |      filename : string
 |          The location to save the JSON file.
 |      
 |      orient : string, optional. Either "records" or "lines"
 |          If orient="records" the file is saved as a single JSON array.
 |          If orient="lines", the file is saves as a JSON value per line.
 |      
 |      Examples
 |      --------
 |      The orient parameter describes the expected input format of the JSON
 |      file.
 |      
 |      If orient="records", the output will be a single JSON Array where
 |      each array element is a dictionary describing the row.
 |      
 |      >>> g
 |      Columns:
 |              a       int
 |              b       int
 |      Rows: 3
 |      Data:
 |      +---+---+
 |      | a | b |
 |      +---+---+
 |      | 1 | 1 |
 |      | 2 | 2 |
 |      | 3 | 3 |
 |      +---+---+
 |      >>> g.export('output.json', orient='records')
 |      >>> !cat output.json
 |      [
 |      {'a':1,'b':1},
 |      {'a':2,'b':2},
 |      {'a':3,'b':3},
 |      ]
 |      
 |      If orient="rows", each row will be emitted as a JSON dictionary to
 |      each file line.
 |      
 |      >>> g
 |      Columns:
 |              a       int
 |              b       int
 |      Rows: 3
 |      Data:
 |      +---+---+
 |      | a | b |
 |      +---+---+
 |      | 1 | 1 |
 |      | 2 | 2 |
 |      | 3 | 3 |
 |      +---+---+
 |      >>> g.export('output.json', orient='rows')
 |      >>> !cat output.json
 |      {'a':1,'b':1}
 |      {'a':2,'b':2}
 |      {'a':3,'b':3}
 |  
 |  fillna(self, column, value)
 |      Fill all missing values with a given value in a given column. If the
 |      ``value`` is not the same type as the values in ``column``, this method
 |      attempts to convert the value to the original column's type. If this
 |      fails, an error is raised.
 |      
 |      Parameters
 |      ----------
 |      column : str
 |          The name of the column to modify.
 |      
 |      value : type convertible to SArray's type
 |          The value used to replace all missing values.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame with the specified value in place of missing values.
 |      
 |      See Also
 |      --------
 |      dropna
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'a':[1, None, None],
 |      ...                       'b':['13.1', '17.2', None]})
 |      >>> sf = sf.fillna('a', 0)
 |      >>> sf
 |      +---+------+
 |      | a |  b   |
 |      +---+------+
 |      | 1 | 13.1 |
 |      | 0 | 17.2 |
 |      | 0 | None |
 |      +---+------+
 |      [3 rows x 2 columns]
 |  
 |  filter_by(self, values, column_name, exclude=False)
 |      Filter an SFrame by values inside an iterable object. Result is an
 |      SFrame that only includes (or excludes) the rows that have a column
 |      with the given ``column_name`` which holds one of the values in the
 |      given ``values`` :class:`~graphlab.SArray`. If ``values`` is not an
 |      SArray, we attempt to convert it to one before filtering.
 |      
 |      Parameters
 |      ----------
 |      values : SArray | list | numpy.ndarray | pandas.Series | str
 |          The values to use to filter the SFrame.  The resulting SFrame will
 |          only include rows that have one of these values in the given
 |          column.
 |      
 |      column_name : str
 |          The column of the SFrame to match with the given `values`.
 |      
 |      exclude : bool
 |          If True, the result SFrame will contain all rows EXCEPT those that
 |          have one of ``values`` in ``column_name``.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The filtered SFrame.
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id': [1, 2, 3, 4],
 |      ...                      'animal_type': ['dog', 'cat', 'cow', 'horse'],
 |      ...                      'name': ['bob', 'jim', 'jimbob', 'bobjim']})
 |      >>> household_pets = ['cat', 'hamster', 'dog', 'fish', 'bird', 'snake']
 |      >>> sf.filter_by(household_pets, 'animal_type')
 |      +-------------+----+------+
 |      | animal_type | id | name |
 |      +-------------+----+------+
 |      |     dog     | 1  | bob  |
 |      |     cat     | 2  | jim  |
 |      +-------------+----+------+
 |      [2 rows x 3 columns]
 |      >>> sf.filter_by(household_pets, 'animal_type', exclude=True)
 |      +-------------+----+--------+
 |      | animal_type | id |  name  |
 |      +-------------+----+--------+
 |      |    horse    | 4  | bobjim |
 |      |     cow     | 3  | jimbob |
 |      +-------------+----+--------+
 |      [2 rows x 3 columns]
 |  
 |  flat_map(self, column_names, fn, column_types='auto', seed=None)
 |      Map each row of the SFrame to multiple rows in a new SFrame via a
 |      function.
 |      
 |      The output of `fn` must have type List[List[...]].  Each inner list
 |      will be a single row in the new output, and the collection of these
 |      rows within the outer list make up the data for the output SFrame.
 |      All rows must have the same length and the same order of types to
 |      make sure the result columns are homogeneously typed.  For example, if
 |      the first element emitted into in the outer list by `fn` is
 |      [43, 2.3, 'string'], then all other elements emitted into the outer
 |      list must be a list with three elements, where the first is an int,
 |      second is a float, and third is a string.  If column_types is not
 |      specified, the first 10 rows of the SFrame are used to determine the
 |      column types of the returned sframe.
 |      
 |      Parameters
 |      ----------
 |      column_names : list[str]
 |          The column names for the returned SFrame.
 |      
 |      fn : function
 |          The function that maps each of the sframe row into multiple rows,
 |          returning List[List[...]].  All outputted rows must have the same
 |          length and order of types.
 |      
 |      column_types : list[type], optional
 |          The column types of the output SFrame. Default value will be
 |          automatically inferred by running `fn` on the first 10 rows of the
 |          input. If the types cannot be inferred from the first 10 rows, an
 |          error is raised.
 |      
 |      seed : int, optional
 |          Used as the seed if a random number generator is included in `fn`.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame containing the results of the flat_map of the
 |          original SFrame.
 |      
 |      Examples
 |      ---------
 |      Repeat each row according to the value in the 'number' column.
 |      
 |      >>> sf = graphlab.SFrame({'letter': ['a', 'b', 'c'],
 |      ...                       'number': [1, 2, 3]})
 |      >>> sf.flat_map(['number', 'letter'],
 |      ...             lambda x: [list(x.itervalues()) for i in range(0, x['number'])])
 |      +--------+--------+
 |      | number | letter |
 |      +--------+--------+
 |      |   1    |   a    |
 |      |   2    |   b    |
 |      |   2    |   b    |
 |      |   3    |   c    |
 |      |   3    |   c    |
 |      |   3    |   c    |
 |      +--------+--------+
 |      [6 rows x 2 columns]
 |  
 |  groupby(self, key_columns, operations, *args)
 |      Perform a group on the key_columns followed by aggregations on the
 |      columns listed in operations.
 |      
 |      The operations parameter is a dictionary that indicates which
 |      aggregation operators to use and which columns to use them on. The
 |      available operators are SUM, MAX, MIN, COUNT, AVG, VAR, STDV, CONCAT,
 |      SELECT_ONE, ARGMIN, ARGMAX, and QUANTILE. For convenience, aggregators
 |      MEAN, STD, and VARIANCE are available as synonyms for AVG, STDV, and
 |      VAR. See :mod:`~graphlab.aggregate` for more detail on the aggregators.
 |      
 |      Parameters
 |      ----------
 |      key_columns : string | list[string]
 |          Column(s) to group by. Key columns can be of any type other than
 |          dictionary.
 |      
 |      operations : dict, list
 |          Dictionary of columns and aggregation operations. Each key is a
 |          output column name and each value is an aggregator. This can also
 |          be a list of aggregators, in which case column names will be
 |          automatically assigned.
 |      
 |      *args
 |          All other remaining arguments will be interpreted in the same
 |          way as the operations argument.
 |      
 |      Returns
 |      -------
 |      out_sf : SFrame
 |          A new SFrame, with a column for each groupby column and each
 |          aggregation operation.
 |      
 |      See Also
 |      --------
 |      aggregate
 |      
 |      Examples
 |      --------
 |      Suppose we have an SFrame with movie ratings by many users.
 |      
 |      >>> import graphlab.aggregate as agg
 |      >>> url = 'http://s3.amazonaws.com/gl-testdata/rating_data_example.csv'
 |      >>> sf = graphlab.SFrame.read_csv(url)
 |      >>> sf
 |      +---------+----------+--------+
 |      | user_id | movie_id | rating |
 |      +---------+----------+--------+
 |      |  25904  |   1663   |   3    |
 |      |  25907  |   1663   |   3    |
 |      |  25923  |   1663   |   3    |
 |      |  25924  |   1663   |   3    |
 |      |  25928  |   1663   |   2    |
 |      |  25933  |   1663   |   4    |
 |      |  25934  |   1663   |   4    |
 |      |  25935  |   1663   |   4    |
 |      |  25936  |   1663   |   5    |
 |      |  25937  |   1663   |   2    |
 |      |   ...   |   ...    |  ...   |
 |      +---------+----------+--------+
 |      [10000 rows x 3 columns]
 |      
 |      Compute the number of occurrences of each user.
 |      
 |      >>> user_count = sf.groupby(key_columns='user_id',
 |      ...                         operations={'count': agg.COUNT()})
 |      >>> user_count
 |      +---------+-------+
 |      | user_id | count |
 |      +---------+-------+
 |      |  62361  |   1   |
 |      |  30727  |   1   |
 |      |  40111  |   1   |
 |      |  50513  |   1   |
 |      |  35140  |   1   |
 |      |  42352  |   1   |
 |      |  29667  |   1   |
 |      |  46242  |   1   |
 |      |  58310  |   1   |
 |      |  64614  |   1   |
 |      |   ...   |  ...  |
 |      +---------+-------+
 |      [9852 rows x 2 columns]
 |      
 |      Compute the mean and standard deviation of ratings per user.
 |      
 |      >>> user_rating_stats = sf.groupby(key_columns='user_id',
 |      ...                                operations={
 |      ...                                    'mean_rating': agg.MEAN('rating'),
 |      ...                                    'std_rating': agg.STD('rating')
 |      ...                                })
 |      >>> user_rating_stats
 |      +---------+-------------+------------+
 |      | user_id | mean_rating | std_rating |
 |      +---------+-------------+------------+
 |      |  62361  |     5.0     |    0.0     |
 |      |  30727  |     4.0     |    0.0     |
 |      |  40111  |     2.0     |    0.0     |
 |      |  50513  |     4.0     |    0.0     |
 |      |  35140  |     4.0     |    0.0     |
 |      |  42352  |     5.0     |    0.0     |
 |      |  29667  |     4.0     |    0.0     |
 |      |  46242  |     5.0     |    0.0     |
 |      |  58310  |     2.0     |    0.0     |
 |      |  64614  |     2.0     |    0.0     |
 |      |   ...   |     ...     |    ...     |
 |      +---------+-------------+------------+
 |      [9852 rows x 3 columns]
 |      
 |      Compute the movie with the minimum rating per user.
 |      
 |      >>> chosen_movies = sf.groupby(key_columns='user_id',
 |      ...                            operations={
 |      ...                                'worst_movies': agg.ARGMIN('rating','movie_id')
 |      ...                            })
 |      >>> chosen_movies
 |      +---------+-------------+
 |      | user_id | worst_movies |
 |      +---------+-------------+
 |      |  62361  |     1663    |
 |      |  30727  |     1663    |
 |      |  40111  |     1663    |
 |      |  50513  |     1663    |
 |      |  35140  |     1663    |
 |      |  42352  |     1663    |
 |      |  29667  |     1663    |
 |      |  46242  |     1663    |
 |      |  58310  |     1663    |
 |      |  64614  |     1663    |
 |      |   ...   |     ...     |
 |      +---------+-------------+
 |      [9852 rows x 2 columns]
 |      
 |      Compute the movie with the max rating per user and also the movie with
 |      the maximum imdb-ranking per user.
 |      
 |      >>> sf['imdb-ranking'] = sf['rating'] * 10
 |      >>> chosen_movies = sf.groupby(key_columns='user_id',
 |      ...         operations={('max_rating_movie','max_imdb_ranking_movie'): agg.ARGMAX(('rating','imdb-ranking'),'movie_id')})
 |      >>> chosen_movies
 |      +---------+------------------+------------------------+
 |      | user_id | max_rating_movie | max_imdb_ranking_movie |
 |      +---------+------------------+------------------------+
 |      |  62361  |       1663       |          16630         |
 |      |  30727  |       1663       |          16630         |
 |      |  40111  |       1663       |          16630         |
 |      |  50513  |       1663       |          16630         |
 |      |  35140  |       1663       |          16630         |
 |      |  42352  |       1663       |          16630         |
 |      |  29667  |       1663       |          16630         |
 |      |  46242  |       1663       |          16630         |
 |      |  58310  |       1663       |          16630         |
 |      |  64614  |       1663       |          16630         |
 |      |   ...   |       ...        |          ...           |
 |      +---------+------------------+------------------------+
 |      [9852 rows x 3 columns]
 |      
 |      Compute the movie with the max rating per user.
 |      
 |      >>> chosen_movies = sf.groupby(key_columns='user_id',
 |                  operations={'best_movies': agg.ARGMAX('rating','movie')})
 |      
 |      Compute the movie with the max rating per user and also the movie with the maximum imdb-ranking per user.
 |      
 |      >>> chosen_movies = sf.groupby(key_columns='user_id',
 |                 operations={('max_rating_movie','max_imdb_ranking_movie'): agg.ARGMAX(('rating','imdb-ranking'),'movie')})
 |      
 |      Compute the count, mean, and standard deviation of ratings per (user,
 |      time), automatically assigning output column names.
 |      
 |      >>> sf['time'] = sf.apply(lambda x: (x['user_id'] + x['movie_id']) % 11 + 2000)
 |      >>> user_rating_stats = sf.groupby(['user_id', 'time'],
 |      ...                                [agg.COUNT(),
 |      ...                                 agg.AVG('rating'),
 |      ...                                 agg.STDV('rating')])
 |      >>> user_rating_stats
 |      +------+---------+-------+---------------+----------------+
 |      | time | user_id | Count | Avg of rating | Stdv of rating |
 |      +------+---------+-------+---------------+----------------+
 |      | 2006 |  61285  |   1   |      4.0      |      0.0       |
 |      | 2000 |  36078  |   1   |      4.0      |      0.0       |
 |      | 2003 |  47158  |   1   |      3.0      |      0.0       |
 |      | 2007 |  34446  |   1   |      3.0      |      0.0       |
 |      | 2010 |  47990  |   1   |      3.0      |      0.0       |
 |      | 2003 |  42120  |   1   |      5.0      |      0.0       |
 |      | 2007 |  44940  |   1   |      4.0      |      0.0       |
 |      | 2008 |  58240  |   1   |      4.0      |      0.0       |
 |      | 2002 |   102   |   1   |      1.0      |      0.0       |
 |      | 2009 |  52708  |   1   |      3.0      |      0.0       |
 |      | ...  |   ...   |  ...  |      ...      |      ...       |
 |      +------+---------+-------+---------------+----------------+
 |      [10000 rows x 5 columns]
 |      
 |      
 |      The groupby function can take a variable length list of aggregation
 |      specifiers so if we want the count and the 0.25 and 0.75 quantiles of
 |      ratings:
 |      
 |      >>> user_rating_stats = sf.groupby(['user_id', 'time'], agg.COUNT(),
 |      ...                                {'rating_quantiles': agg.QUANTILE('rating',[0.25, 0.75])})
 |      >>> user_rating_stats
 |      +------+---------+-------+------------------------+
 |      | time | user_id | Count |    rating_quantiles    |
 |      +------+---------+-------+------------------------+
 |      | 2006 |  61285  |   1   | array('d', [4.0, 4.0]) |
 |      | 2000 |  36078  |   1   | array('d', [4.0, 4.0]) |
 |      | 2003 |  47158  |   1   | array('d', [3.0, 3.0]) |
 |      | 2007 |  34446  |   1   | array('d', [3.0, 3.0]) |
 |      | 2010 |  47990  |   1   | array('d', [3.0, 3.0]) |
 |      | 2003 |  42120  |   1   | array('d', [5.0, 5.0]) |
 |      | 2007 |  44940  |   1   | array('d', [4.0, 4.0]) |
 |      | 2008 |  58240  |   1   | array('d', [4.0, 4.0]) |
 |      | 2002 |   102   |   1   | array('d', [1.0, 1.0]) |
 |      | 2009 |  52708  |   1   | array('d', [3.0, 3.0]) |
 |      | ...  |   ...   |  ...  |          ...           |
 |      +------+---------+-------+------------------------+
 |      [10000 rows x 4 columns]
 |      
 |      To put all items a user rated into one list value by their star rating:
 |      
 |      >>> user_rating_stats = sf.groupby(["user_id", "rating"],
 |      ...                                {"rated_movie_ids":agg.CONCAT("movie_id")})
 |      >>> user_rating_stats
 |      +--------+---------+----------------------+
 |      | rating | user_id |     rated_movie_ids  |
 |      +--------+---------+----------------------+
 |      |   3    |  31434  | array('d', [1663.0]) |
 |      |   5    |  25944  | array('d', [1663.0]) |
 |      |   4    |  38827  | array('d', [1663.0]) |
 |      |   4    |  51437  | array('d', [1663.0]) |
 |      |   4    |  42549  | array('d', [1663.0]) |
 |      |   4    |  49532  | array('d', [1663.0]) |
 |      |   3    |  26124  | array('d', [1663.0]) |
 |      |   4    |  46336  | array('d', [1663.0]) |
 |      |   4    |  52133  | array('d', [1663.0]) |
 |      |   5    |  62361  | array('d', [1663.0]) |
 |      |  ...   |   ...   |         ...          |
 |      +--------+---------+----------------------+
 |      [9952 rows x 3 columns]
 |      
 |      To put all items and rating of a given user together into a dictionary
 |      value:
 |      
 |      >>> user_rating_stats = sf.groupby("user_id",
 |      ...                                {"movie_rating":agg.CONCAT("movie_id", "rating")})
 |      >>> user_rating_stats
 |      +---------+--------------+
 |      | user_id | movie_rating |
 |      +---------+--------------+
 |      |  62361  |  {1663: 5}   |
 |      |  30727  |  {1663: 4}   |
 |      |  40111  |  {1663: 2}   |
 |      |  50513  |  {1663: 4}   |
 |      |  35140  |  {1663: 4}   |
 |      |  42352  |  {1663: 5}   |
 |      |  29667  |  {1663: 4}   |
 |      |  46242  |  {1663: 5}   |
 |      |  58310  |  {1663: 2}   |
 |      |  64614  |  {1663: 2}   |
 |      |   ...   |     ...      |
 |      +---------+--------------+
 |      [9852 rows x 2 columns]
 |  
 |  head(self, n=10)
 |      The first n rows of the SFrame.
 |      
 |      Parameters
 |      ----------
 |      n : int, optional
 |          The number of rows to fetch.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame which contains the first n rows of the current SFrame
 |      
 |      See Also
 |      --------
 |      tail, print_rows
 |  
 |  join(self, right, on=None, how='inner')
 |      Merge two SFrames. Merges the current (left) SFrame with the given
 |      (right) SFrame using a SQL-style equi-join operation by columns.
 |      
 |      Parameters
 |      ----------
 |      right : SFrame
 |          The SFrame to join.
 |      
 |      on : None | str | list | dict, optional
 |          The column name(s) representing the set of join keys.  Each row that
 |          has the same value in this set of columns will be merged together.
 |      
 |          * If 'None' is given, join will use all columns that have the same
 |            name as the set of join keys.
 |      
 |          * If a str is given, this is interpreted as a join using one column,
 |            where both SFrames have the same column name.
 |      
 |          * If a list is given, this is interpreted as a join using one or
 |            more column names, where each column name given exists in both
 |            SFrames.
 |      
 |          * If a dict is given, each dict key is taken as a column name in the
 |            left SFrame, and each dict value is taken as the column name in
 |            right SFrame that will be joined together. e.g.
 |            {'left_col_name':'right_col_name'}.
 |      
 |      how : {'left', 'right', 'outer', 'inner'}, optional
 |          The type of join to perform.  'inner' is default.
 |      
 |          * inner: Equivalent to a SQL inner join.  Result consists of the
 |            rows from the two frames whose join key values match exactly,
 |            merged together into one SFrame.
 |      
 |          * left: Equivalent to a SQL left outer join. Result is the union
 |            between the result of an inner join and the rest of the rows from
 |            the left SFrame, merged with missing values.
 |      
 |          * right: Equivalent to a SQL right outer join.  Result is the union
 |            between the result of an inner join and the rest of the rows from
 |            the right SFrame, merged with missing values.
 |      
 |          * outer: Equivalent to a SQL full outer join. Result is
 |            the union between the result of a left outer join and a right
 |            outer join.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |      
 |      Examples
 |      --------
 |      >>> animals = graphlab.SFrame({'id': [1, 2, 3, 4],
 |      ...                           'name': ['dog', 'cat', 'sheep', 'cow']})
 |      >>> sounds = graphlab.SFrame({'id': [1, 3, 4, 5],
 |      ...                          'sound': ['woof', 'baa', 'moo', 'oink']})
 |      >>> animals.join(sounds, how='inner')
 |      +----+-------+-------+
 |      | id |  name | sound |
 |      +----+-------+-------+
 |      | 1  |  dog  |  woof |
 |      | 3  | sheep |  baa  |
 |      | 4  |  cow  |  moo  |
 |      +----+-------+-------+
 |      [3 rows x 3 columns]
 |      
 |      >>> animals.join(sounds, on='id', how='left')
 |      +----+-------+-------+
 |      | id |  name | sound |
 |      +----+-------+-------+
 |      | 1  |  dog  |  woof |
 |      | 3  | sheep |  baa  |
 |      | 4  |  cow  |  moo  |
 |      | 2  |  cat  |  None |
 |      +----+-------+-------+
 |      [4 rows x 3 columns]
 |      
 |      >>> animals.join(sounds, on=['id'], how='right')
 |      +----+-------+-------+
 |      | id |  name | sound |
 |      +----+-------+-------+
 |      | 1  |  dog  |  woof |
 |      | 3  | sheep |  baa  |
 |      | 4  |  cow  |  moo  |
 |      | 5  |  None |  oink |
 |      +----+-------+-------+
 |      [4 rows x 3 columns]
 |      
 |      >>> animals.join(sounds, on={'id':'id'}, how='outer')
 |      +----+-------+-------+
 |      | id |  name | sound |
 |      +----+-------+-------+
 |      | 1  |  dog  |  woof |
 |      | 3  | sheep |  baa  |
 |      | 4  |  cow  |  moo  |
 |      | 5  |  None |  oink |
 |      | 2  |  cat  |  None |
 |      +----+-------+-------+
 |      [5 rows x 3 columns]
 |  
 |  num_cols(self)
 |      The number of columns in this SFrame.
 |      
 |      Returns
 |      -------
 |      out : int
 |          Number of columns in the SFrame.
 |      
 |      See Also
 |      --------
 |      num_columns, num_rows
 |  
 |  num_columns(self)
 |      The number of columns in this SFrame.
 |      
 |      Returns
 |      -------
 |      out : int
 |          Number of columns in the SFrame.
 |      
 |      See Also
 |      --------
 |      num_cols, num_rows
 |  
 |  num_rows(self)
 |      The number of rows in this SFrame.
 |      
 |      Returns
 |      -------
 |      out : int
 |          Number of rows in the SFrame.
 |      
 |      See Also
 |      --------
 |      num_columns
 |  
 |  pack_columns(self, columns=None, column_prefix=None, dtype=<type 'list'>, fill_na=None, remove_prefix=True, new_column_name=None)
 |      Pack columns of the current SFrame into one single column. The result
 |      is a new SFrame with the unaffected columns from the original SFrame
 |      plus the newly created column.
 |      
 |      The list of columns that are packed is chosen through either the
 |      ``columns`` or ``column_prefix`` parameter. Only one of the parameters
 |      is allowed to be provided. ``columns`` explicitly specifies the list of
 |      columns to pack, while ``column_prefix`` specifies that all columns that
 |      have the given prefix are to be packed.
 |      
 |      The type of the resulting column is decided by the ``dtype`` parameter.
 |      Allowed values for ``dtype`` are dict, array.array and list:
 |      
 |       - *dict*: pack to a dictionary SArray where column name becomes
 |         dictionary key and column value becomes dictionary value
 |      
 |       - *array.array*: pack all values from the packing columns into an array
 |      
 |       - *list*: pack all values from the packing columns into a list.
 |      
 |      Parameters
 |      ----------
 |      columns : list[str], optional
 |          A list of column names to be packed.  If omitted and
 |          `column_prefix` is not specified, all columns from current SFrame
 |          are packed.  This parameter is mutually exclusive with the
 |          `column_prefix` parameter.
 |      
 |      column_prefix : str, optional
 |          Pack all columns with the given `column_prefix`.
 |          This parameter is mutually exclusive with the `columns` parameter.
 |      
 |      dtype : dict | array.array | list, optional
 |          The resulting packed column type. If not provided, dtype is list.
 |      
 |      fill_na : value, optional
 |          Value to fill into packed column if missing value is encountered.
 |          If packing to dictionary, `fill_na` is only applicable to dictionary
 |          values; missing keys are not replaced.
 |      
 |      remove_prefix : bool, optional
 |          If True and `column_prefix` is specified, the dictionary key will
 |          be constructed by removing the prefix from the column name.
 |          This option is only applicable when packing to dict type.
 |      
 |      new_column_name : str, optional
 |          Packed column name.  If not given and `column_prefix` is given,
 |          then the prefix will be used as the new column name, otherwise name
 |          is generated automatically.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          An SFrame that contains columns that are not packed, plus the newly
 |          packed column.
 |      
 |      See Also
 |      --------
 |      unpack
 |      
 |      Notes
 |      -----
 |      - If packing to dictionary, missing key is always dropped. Missing
 |        values are dropped if fill_na is not provided, otherwise, missing
 |        value is replaced by 'fill_na'. If packing to list or array, missing
 |        values will be kept. If 'fill_na' is provided, the missing value is
 |        replaced with 'fill_na' value.
 |      
 |      Examples
 |      --------
 |      Suppose 'sf' is an an SFrame that maintains business category
 |      information:
 |      
 |      >>> sf = graphlab.SFrame({'business': range(1, 5),
 |      ...                       'category.retail': [1, None, 1, None],
 |      ...                       'category.food': [1, 1, None, None],
 |      ...                       'category.service': [None, 1, 1, None],
 |      ...                       'category.shop': [1, 1, None, 1]})
 |      >>> sf
 |      +----------+-----------------+---------------+------------------+---------------+
 |      | business | category.retail | category.food | category.service | category.shop |
 |      +----------+-----------------+---------------+------------------+---------------+
 |      |    1     |        1        |       1       |       None       |       1       |
 |      |    2     |       None      |       1       |        1         |       1       |
 |      |    3     |        1        |      None     |        1         |      None     |
 |      |    4     |       None      |       1       |       None       |       1       |
 |      +----------+-----------------+---------------+------------------+---------------+
 |      [4 rows x 5 columns]
 |      
 |      To pack all category columns into a list:
 |      
 |      >>> sf.pack_columns(column_prefix='category')
 |      +----------+--------------------+
 |      | business |         X2         |
 |      +----------+--------------------+
 |      |    1     |  [1, 1, None, 1]   |
 |      |    2     |  [None, 1, 1, 1]   |
 |      |    3     | [1, None, 1, None] |
 |      |    4     | [None, 1, None, 1] |
 |      +----------+--------------------+
 |      [4 rows x 2 columns]
 |      
 |      To pack all category columns into a dictionary, with new column name:
 |      
 |      >>> sf.pack_columns(column_prefix='category', dtype=dict,
 |      ...                 new_column_name='category')
 |      +----------+--------------------------------+
 |      | business |            category            |
 |      +----------+--------------------------------+
 |      |    1     | {'food': 1, 'shop': 1, 're ... |
 |      |    2     | {'food': 1, 'shop': 1, 'se ... |
 |      |    3     |  {'retail': 1, 'service': 1}   |
 |      |    4     |     {'food': 1, 'shop': 1}     |
 |      +----------+--------------------------------+
 |      [4 rows x 2 columns]
 |      
 |      To keep column prefix in the resulting dict key:
 |      
 |      >>> sf.pack_columns(column_prefix='category', dtype=dict,
 |                          remove_prefix=False)
 |      +----------+--------------------------------+
 |      | business |               X2               |
 |      +----------+--------------------------------+
 |      |    1     | {'category.retail': 1, 'ca ... |
 |      |    2     | {'category.food': 1, 'cate ... |
 |      |    3     | {'category.retail': 1, 'ca ... |
 |      |    4     | {'category.food': 1, 'cate ... |
 |      +----------+--------------------------------+
 |      [4 rows x 2 columns]
 |      
 |      To explicitly pack a set of columns:
 |      
 |      >>> sf.pack_columns(columns = ['business', 'category.retail',
 |                                     'category.food', 'category.service',
 |                                     'category.shop'])
 |      +-----------------------+
 |      |           X1          |
 |      +-----------------------+
 |      |   [1, 1, 1, None, 1]  |
 |      |   [2, None, 1, 1, 1]  |
 |      | [3, 1, None, 1, None] |
 |      | [4, None, 1, None, 1] |
 |      +-----------------------+
 |      [4 rows x 1 columns]
 |      
 |      To pack all columns with name starting with 'category' into an array
 |      type, and with missing value replaced with 0:
 |      
 |      >>> sf.pack_columns(column_prefix="category", dtype=array.array,
 |      ...                 fill_na=0)
 |      +----------+--------------------------------+
 |      | business |               X2               |
 |      +----------+--------------------------------+
 |      |    1     | array('d', [1.0, 1.0, 0.0, ... |
 |      |    2     | array('d', [0.0, 1.0, 1.0, ... |
 |      |    3     | array('d', [1.0, 0.0, 1.0, ... |
 |      |    4     | array('d', [0.0, 1.0, 0.0, ... |
 |      +----------+--------------------------------+
 |      [4 rows x 2 columns]
 |  
 |  print_rows(self, num_rows=10, num_columns=40, max_column_width=30, max_row_width=80, output_file=<ipykernel.iostream.OutStream object>)
 |      Print the first M rows and N columns of the SFrame in human readable
 |      format.
 |      
 |      Parameters
 |      ----------
 |      num_rows : int, optional
 |          Number of rows to print.
 |      
 |      num_columns : int, optional
 |          Number of columns to print.
 |      
 |      max_column_width : int, optional
 |          Maximum width of a column. Columns use fewer characters if possible.
 |      
 |      max_row_width : int, optional
 |          Maximum width of a printed row. Columns beyond this width wrap to a
 |          new line. `max_row_width` is automatically reset to be the
 |          larger of itself and `max_column_width`.
 |      
 |      See Also
 |      --------
 |      head, tail
 |  
 |  random_split(self, fraction, seed=None)
 |      Randomly split the rows of an SFrame into two SFrames. The first SFrame
 |      contains *M* rows, sampled uniformly (without replacement) from the
 |      original SFrame. *M* is approximately the fraction times the original
 |      number of rows. The second SFrame contains the remaining rows of the
 |      original SFrame.
 |      
 |      Parameters
 |      ----------
 |      fraction : float
 |          Approximate fraction of the rows to fetch for the first returned
 |          SFrame. Must be between 0 and 1.
 |      
 |      seed : int, optional
 |          Seed for the random number generator used to split.
 |      
 |      Returns
 |      -------
 |      out : tuple [SFrame]
 |          Two new SFrames.
 |      
 |      Examples
 |      --------
 |      Suppose we have an SFrame with 1,024 rows and we want to randomly split
 |      it into training and testing datasets with about a 90%/10% split.
 |      
 |      >>> sf = graphlab.SFrame({'id': range(1024)})
 |      >>> sf_train, sf_test = sf.random_split(.9, seed=5)
 |      >>> print len(sf_train), len(sf_test)
 |      922 102
 |  
 |  remove_column(self, name)
 |      Remove a column from this SFrame. This operation modifies the current
 |      SFrame in place and returns self.
 |      
 |      Parameters
 |      ----------
 |      name : string
 |          The name of the column to remove.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The SFrame with given column removed.
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id': [1, 2, 3], 'val': ['A', 'B', 'C']})
 |      >>> # This is equivalent to `del sf['val']`
 |      >>> sf.remove_column('val')
 |      >>> sf
 |      +----+
 |      | id |
 |      +----+
 |      | 1  |
 |      | 2  |
 |      | 3  |
 |      +----+
 |      [3 rows x 1 columns]
 |  
 |  remove_columns(self, column_names)
 |      Remove one or more columns from this SFrame. This operation modifies the current
 |      SFrame in place and returns self.
 |      
 |      Parameters
 |      ----------
 |      column_names : list or iterable
 |          A list or iterable of column names.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The SFrame with given columns removed.
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id': [1, 2, 3], 'val1': ['A', 'B', 'C'], 'val2' : [10, 11, 12]})
 |      >>> sf.remove_columns(['val1', 'val2'])
 |      >>> sf
 |      +----+
 |      | id |
 |      +----+
 |      | 1  |
 |      | 2  |
 |      | 3  |
 |      +----+
 |      [3 rows x 1 columns]
 |  
 |  rename(self, names)
 |      Rename the given columns. ``names`` is expected to be a dict specifying
 |      the old and new names. This changes the names of the columns given as
 |      the keys and replaces them with the names given as the values.  This
 |      operation modifies the current SFrame in place and returns self.
 |      
 |      Parameters
 |      ----------
 |      names : dict [string, string]
 |          Dictionary of [old_name, new_name]
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The current SFrame.
 |      
 |      See Also
 |      --------
 |      column_names
 |      
 |      Examples
 |      --------
 |      >>> sf = SFrame({'X1': ['Alice','Bob'],
 |      ...              'X2': ['123 Fake Street','456 Fake Street']})
 |      >>> sf.rename({'X1': 'name', 'X2':'address'})
 |      >>> sf
 |      +-------+-----------------+
 |      |  name |     address     |
 |      +-------+-----------------+
 |      | Alice | 123 Fake Street |
 |      |  Bob  | 456 Fake Street |
 |      +-------+-----------------+
 |      [2 rows x 2 columns]
 |  
 |  sample(self, fraction, seed=None)
 |      Sample the current SFrame's rows.
 |      
 |      Parameters
 |      ----------
 |      fraction : float
 |          Approximate fraction of the rows to fetch. Must be between 0 and 1.
 |          The number of rows returned is approximately the fraction times the
 |          number of rows.
 |      
 |      seed : int, optional
 |          Seed for the random number generator used to sample.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame containing sampled rows of the current SFrame.
 |      
 |      Examples
 |      --------
 |      Suppose we have an SFrame with 6,145 rows.
 |      
 |      >>> import random
 |      >>> sf = SFrame({'id': range(0, 6145)})
 |      
 |      Retrieve about 30% of the SFrame rows with repeatable results by
 |      setting the random seed.
 |      
 |      >>> len(sf.sample(.3, seed=5))
 |      1783
 |  
 |  save(self, filename, format=None)
 |      Save the SFrame to a file system for later use.
 |      
 |      Parameters
 |      ----------
 |      filename : string
 |          The location to save the SFrame. Either a local directory or a
 |          remote URL. If the format is 'binary', a directory will be created
 |          at the location which will contain the sframe.
 |      
 |      format : {'binary', 'csv', 'json'}, optional
 |          Format in which to save the SFrame. Binary saved SFrames can be
 |          loaded much faster and without any format conversion losses. If not
 |          given, will try to infer the format from filename given. If file
 |          name ends with 'csv' or '.csv.gz', then save as 'csv' format,
 |          otherwise save as 'binary' format.
 |          See export_csv for more csv saving options.
 |      
 |      See Also
 |      --------
 |      load_sframe, SFrame
 |      
 |      Examples
 |      --------
 |      >>> # Save the sframe into binary format
 |      >>> sf.save('data/training_data_sframe')
 |      
 |      >>> # Save the sframe into csv format
 |      >>> sf.save('data/training_data.csv', format='csv')
 |  
 |  select_column(self, key)
 |      Get a reference to the :class:`~graphlab.SArray` that corresponds with
 |      the given key. Throws an exception if the key is something other than a
 |      string or if the key is not found.
 |      
 |      Parameters
 |      ----------
 |      key : str
 |          The column name.
 |      
 |      Returns
 |      -------
 |      out : SArray
 |          The SArray that is referred by ``key``.
 |      
 |      See Also
 |      --------
 |      select_columns
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'user_id': [1,2,3],
 |      ...                       'user_name': ['alice', 'bob', 'charlie']})
 |      >>> # This line is equivalent to `sa = sf['user_name']`
 |      >>> sa = sf.select_column('user_name')
 |      >>> sa
 |      dtype: str
 |      Rows: 3
 |      ['alice', 'bob', 'charlie']
 |  
 |  select_columns(self, keylist)
 |      Selects all columns where the name of the column or the type of column
 |      is included in the keylist. An exception is raised if duplicate columns
 |      are selected i.e. sf.select_columns(['a','a']), or non-existant columns
 |      are selected.
 |      
 |      Throws an exception for all other input types.
 |      
 |      Parameters
 |      ----------
 |      keylist : list[str or type]
 |          The list of column names or a list of types.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame that is made up of the columns referred to in
 |          ``keylist`` from the current SFrame.
 |      
 |      See Also
 |      --------
 |      select_column
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'user_id': [1,2,3],
 |      ...                       'user_name': ['alice', 'bob', 'charlie'],
 |      ...                       'zipcode': [98101, 98102, 98103]
 |      ...                      })
 |      >>> # This line is equivalent to `sf2 = sf[['user_id', 'zipcode']]`
 |      >>> sf2 = sf.select_columns(['user_id', 'zipcode'])
 |      >>> sf2
 |      +---------+---------+
 |      | user_id | zipcode |
 |      +---------+---------+
 |      |    1    |  98101  |
 |      |    2    |  98102  |
 |      |    3    |  98103  |
 |      +---------+---------+
 |      [3 rows x 2 columns]
 |  
 |  show(self, columns=None, view=None, x=None, y=None)
 |      show(columns=None, view=None, x=None, y=None)
 |      
 |      Visualize the SFrame with GraphLab Create :mod:`~graphlab.canvas`. This function
 |      starts Canvas if it is not already running. If the SFrame has already been plotted,
 |      this function will update the plot.
 |      
 |      Parameters
 |      ----------
 |      view : str, optional
 |          The name of the SFrame view to show. Can be one of:
 |      
 |          - None: Use the default (depends on which Canvas target is set).
 |          - 'Table': Show a scrollable, tabular view of the data in the
 |            SFrame.
 |          - 'Summary': Show a list of columns with some summary statistics
 |            and plots for each column.
 |          - 'Scatter Plot': Show a scatter plot of two numeric columns.
 |          - 'Heat Map': Show a heat map of two numeric columns.
 |          - 'Bar Chart': Show a bar chart of one numeric and one categorical
 |            column.
 |          - 'BoxWhisker Plot': Show a box and whisker plot of one numeric and one
 |            categorical column.
 |          - 'Line Chart': Show a line chart of one numeric and one
 |            categorical column.
 |      
 |      x : str, optional
 |          The column to use for the X axis in a Scatter Plot, Heat Map, Bar
 |          Chart, or Line Chart view. Must be the name of one of the columns
 |          in this SFrame. For Scatter Plot and Heat Map, the column must be
 |          numeric (int or float). If not set, defaults to the first available
 |          valid column.
 |      
 |      y : str, optional
 |          The column to use for the Y axis in a Scatter Plot, Heat Map, Bar
 |          Chart, or Line Chart view. Must be the name of one of the numeric
 |          columns in this SFrame. If not set, defaults to the second
 |          available numeric column.
 |      
 |      Returns
 |      -------
 |      view : graphlab.canvas.view.View
 |          An object representing the GraphLab Canvas view.
 |      
 |      See Also
 |      --------
 |      canvas
 |      
 |      Examples
 |      --------
 |      Suppose 'sf' is an SFrame, we can view it in GraphLab Canvas using:
 |      
 |      >>> sf.show()
 |      
 |      To choose a specific view of the SFrame:
 |      
 |      >>> sf.show(view="Summary")
 |      >>> sf.show(view="Table")
 |      >>> sf.show(view="Bar Chart", x="col1", y="col2")
 |      >>> sf.show(view="Line Chart", x="col1", y="col2")
 |      >>> sf.show(view="Scatter Plot", x="col1", y="col2")
 |      >>> sf.show(view="Heat Map", x="col1", y="col2")
 |  
 |  sort(self, sort_columns, ascending=True)
 |      Sort current SFrame by the given columns, using the given sort order.
 |      Only columns that are type of str, int and float can be sorted.
 |      
 |      Parameters
 |      ----------
 |      sort_columns : str | list of str | list of (str, bool) pairs
 |          Names of columns to be sorted.  The result will be sorted first by
 |          first column, followed by second column, and so on. All columns will
 |          be sorted in the same order as governed by the `ascending`
 |          parameter. To control the sort ordering for each column
 |          individually, `sort_columns` must be a list of (str, bool) pairs.
 |          Given this case, the first value is the column name and the second
 |          value is a boolean indicating whether the sort order is ascending.
 |      
 |      ascending : bool, optional
 |          Sort all columns in the given order.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame that is sorted according to given sort criteria
 |      
 |      See Also
 |      --------
 |      topk
 |      
 |      Examples
 |      --------
 |      Suppose 'sf' is an sframe that has three columns 'a', 'b', 'c'.
 |      To sort by column 'a', ascending
 |      
 |      >>> sf = graphlab.SFrame({'a':[1,3,2,1],
 |      ...                       'b':['a','c','b','b'],
 |      ...                       'c':['x','y','z','y']})
 |      >>> sf
 |      +---+---+---+
 |      | a | b | c |
 |      +---+---+---+
 |      | 1 | a | x |
 |      | 3 | c | y |
 |      | 2 | b | z |
 |      | 1 | b | y |
 |      +---+---+---+
 |      [4 rows x 3 columns]
 |      
 |      >>> sf.sort('a')
 |      +---+---+---+
 |      | a | b | c |
 |      +---+---+---+
 |      | 1 | a | x |
 |      | 1 | b | y |
 |      | 2 | b | z |
 |      | 3 | c | y |
 |      +---+---+---+
 |      [4 rows x 3 columns]
 |      
 |      To sort by column 'a', descending
 |      
 |      >>> sf.sort('a', ascending = False)
 |      +---+---+---+
 |      | a | b | c |
 |      +---+---+---+
 |      | 3 | c | y |
 |      | 2 | b | z |
 |      | 1 | a | x |
 |      | 1 | b | y |
 |      +---+---+---+
 |      [4 rows x 3 columns]
 |      
 |      To sort by column 'a' and 'b', all ascending
 |      
 |      >>> sf.sort(['a', 'b'])
 |      +---+---+---+
 |      | a | b | c |
 |      +---+---+---+
 |      | 1 | a | x |
 |      | 1 | b | y |
 |      | 2 | b | z |
 |      | 3 | c | y |
 |      +---+---+---+
 |      [4 rows x 3 columns]
 |      
 |      To sort by column 'a' ascending, and then by column 'c' descending
 |      
 |      >>> sf.sort([('a', True), ('c', False)])
 |      +---+---+---+
 |      | a | b | c |
 |      +---+---+---+
 |      | 1 | b | y |
 |      | 1 | a | x |
 |      | 2 | b | z |
 |      | 3 | c | y |
 |      +---+---+---+
 |      [4 rows x 3 columns]
 |  
 |  split_datetime(self, expand_column, column_name_prefix=None, limit=None, tzone=False)
 |      Splits a datetime column of SFrame to multiple columns, with each value in a
 |      separate column. Returns a new SFrame with the expanded column replaced with
 |      a list of new columns. The expanded column must be of datetime type.
 |      
 |      For more details regarding name generation and
 |      other, refer to :py:func:`graphlab.SArray.split_datetime()`
 |      
 |      Parameters
 |      ----------
 |      expand_column : str
 |          Name of the unpacked column.
 |      
 |      column_name_prefix : str, optional
 |          If provided, expanded column names would start with the given prefix.
 |          If not provided, the default value is the name of the expanded column.
 |      
 |      limit: list[str], optional
 |          Limits the set of datetime elements to expand.
 |          Possible values are 'year','month','day','hour','minute','second',
 |          'weekday', 'isoweekday', 'tmweekday', and 'us'.
 |          If not provided, only ['year','month','day','hour','minute','second']
 |          are expanded.
 |      
 |      tzone : bool, optional
 |          A boolean parameter that determines whether to show the timezone
 |          column or not. Defaults to False.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame that contains rest of columns from original SFrame with
 |          the given column replaced with a collection of expanded columns.
 |      
 |      Examples
 |      ---------
 |      
 |      >>> sf
 |      Columns:
 |          id   int
 |          submission  datetime
 |      Rows: 2
 |      Data:
 |          +----+-------------------------------------------------+
 |          | id |               submission                        |
 |          +----+-------------------------------------------------+
 |          | 1  | datetime(2011, 1, 21, 7, 17, 21, tzinfo=GMT(+1))|
 |          | 2  | datetime(2011, 1, 21, 5, 43, 21, tzinfo=GMT(+1))|
 |          +----+-------------------------------------------------+
 |      
 |      >>> sf.split_datetime('submission',limit=['hour','minute'])
 |      Columns:
 |          id  int
 |          submission.hour int
 |          submission.minute int
 |      Rows: 2
 |      Data:
 |      +----+-----------------+-------------------+
 |      | id | submission.hour | submission.minute |
 |      +----+-----------------+-------------------+
 |      | 1  |        7        |        17         |
 |      | 2  |        5        |        43         |
 |      +----+-----------------+-------------------+
 |  
 |  stack(self, column_name, new_column_name=None, drop_na=False, new_column_type=None)
 |      Convert a "wide" column of an SFrame to one or two "tall" columns by
 |      stacking all values.
 |      
 |      The stack works only for columns of dict, list, or array type.  If the
 |      column is dict type, two new columns are created as a result of
 |      stacking: one column holds the key and another column holds the value.
 |      The rest of the columns are repeated for each key/value pair.
 |      
 |      If the column is array or list type, one new column is created as a
 |      result of stacking. With each row holds one element of the array or list
 |      value, and the rest columns from the same original row repeated.
 |      
 |      The new SFrame includes the newly created column and all columns other
 |      than the one that is stacked.
 |      
 |      Parameters
 |      --------------
 |      column_name : str
 |          The column to stack. This column must be of dict/list/array type
 |      
 |      new_column_name : str | list of str, optional
 |          The new column name(s). If original column is list/array type,
 |          new_column_name must a string. If original column is dict type,
 |          new_column_name must be a list of two strings. If not given, column
 |          names are generated automatically.
 |      
 |      drop_na : boolean, optional
 |          If True, missing values and empty list/array/dict are all dropped
 |          from the resulting column(s). If False, missing values are
 |          maintained in stacked column(s).
 |      
 |      new_column_type : type | list of types, optional
 |          The new column types. If original column is a list/array type
 |          new_column_type must be a single type, or a list of one type. If
 |          original column is of dict type, new_column_type must be a list of
 |          two types. If not provided, the types are automatically inferred
 |          from the first 100 values of the SFrame.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame that contains newly stacked column(s) plus columns in
 |          original SFrame other than the stacked column.
 |      
 |      See Also
 |      --------
 |      unstack
 |      
 |      Examples
 |      ---------
 |      Suppose 'sf' is an SFrame that contains a column of dict type:
 |      
 |      >>> sf = graphlab.SFrame({'topic':[1,2,3,4],
 |      ...                       'words': [{'a':3, 'cat':2},
 |      ...                                 {'a':1, 'the':2},
 |      ...                                 {'the':1, 'dog':3},
 |      ...                                 {}]
 |      ...                      })
 |      +-------+----------------------+
 |      | topic |        words         |
 |      +-------+----------------------+
 |      |   1   |  {'a': 3, 'cat': 2}  |
 |      |   2   |  {'a': 1, 'the': 2}  |
 |      |   3   | {'the': 1, 'dog': 3} |
 |      |   4   |          {}          |
 |      +-------+----------------------+
 |      [4 rows x 2 columns]
 |      
 |      Stack would stack all keys in one column and all values in another
 |      column:
 |      
 |      >>> sf.stack('words', new_column_name=['word', 'count'])
 |      +-------+------+-------+
 |      | topic | word | count |
 |      +-------+------+-------+
 |      |   1   |  a   |   3   |
 |      |   1   | cat  |   2   |
 |      |   2   |  a   |   1   |
 |      |   2   | the  |   2   |
 |      |   3   | the  |   1   |
 |      |   3   | dog  |   3   |
 |      |   4   | None |  None |
 |      +-------+------+-------+
 |      [7 rows x 3 columns]
 |      
 |      Observe that since topic 4 had no words, an empty row is inserted.
 |      To drop that row, set dropna=True in the parameters to stack.
 |      
 |      Suppose 'sf' is an SFrame that contains a user and his/her friends,
 |      where 'friends' columns is an array type. Stack on 'friends' column
 |      would create a user/friend list for each user/friend pair:
 |      
 |      >>> sf = graphlab.SFrame({'topic':[1,2,3],
 |      ...                       'friends':[[2,3,4], [5,6],
 |      ...                                  [4,5,10,None]]
 |      ...                      })
 |      >>> sf
 |      +-------+------------------+
 |      | topic |     friends      |
 |      +-------+------------------+
 |      |  1    |     [2, 3, 4]    |
 |      |  2    |      [5, 6]      |
 |      |  3    | [4, 5, 10, None] |
 |      +----- -+------------------+
 |      [3 rows x 2 columns]
 |      
 |      >>> sf.stack('friends', new_column_name='friend')
 |      +------+--------+
 |      | user | friend |
 |      +------+--------+
 |      |  1   |  2     |
 |      |  1   |  3     |
 |      |  1   |  4     |
 |      |  2   |  5     |
 |      |  2   |  6     |
 |      |  3   |  4     |
 |      |  3   |  5     |
 |      |  3   |  10    |
 |      |  3   |  None  |
 |      +------+--------+
 |      [9 rows x 2 columns]
 |  
 |  swap_columns(self, column_1, column_2)
 |      Swap the columns with the given names. This operation modifies the
 |      current SFrame in place and returns self.
 |      
 |      Parameters
 |      ----------
 |      column_1 : string
 |          Name of column to swap
 |      
 |      column_2 : string
 |          Name of other column to swap
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          The SFrame with swapped columns.
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id': [1, 2, 3], 'val': ['A', 'B', 'C']})
 |      >>> sf.swap_columns('id', 'val')
 |      >>> sf
 |      +-----+-----+
 |      | val | id  |
 |      +-----+-----+
 |      |  A  |  1  |
 |      |  B  |  2  |
 |      |  C  |  3  |
 |      +----+-----+
 |      [3 rows x 2 columns]
 |  
 |  tail(self, n=10)
 |      The last n rows of the SFrame.
 |      
 |      Parameters
 |      ----------
 |      n : int, optional
 |          The number of rows to fetch.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame which contains the last n rows of the current SFrame
 |      
 |      See Also
 |      --------
 |      head, print_rows
 |  
 |  to_dataframe(self)
 |      Convert this SFrame to pandas.DataFrame.
 |      
 |      This operation will construct a pandas.DataFrame in memory. Care must
 |      be taken when size of the returned object is big.
 |      
 |      Returns
 |      -------
 |      out : pandas.DataFrame
 |          The dataframe which contains all rows of SFrame
 |  
 |  to_numpy(self)
 |      Converts this SFrame to a numpy array
 |      
 |      This operation will construct a numpy array in memory. Care must
 |      be taken when size of the returned object is big.
 |      
 |      Returns
 |      -------
 |      out : numpy.ndarray
 |          A Numpy Array containing all the values of the SFrame
 |  
 |  to_odbc(self, db, table_name, append_if_exists=False, verbose=True)
 |      Convert an SFrame to a table in a database.
 |      
 |      By default, searches for a table in the database with the given name.
 |      If found, this will attempt to append all the rows of the SFrame to the
 |      end of the table.  If not, this will create a new table with the given
 |      name.  This behavior is toggled with the `append_if_exists` flag.
 |      
 |      When creating a new table, GraphLab Create uses a heuristic approach to
 |      pick a corresponding type for each column in the SFrame using the type
 |      information supplied by the database's ODBC driver.  Your driver must
 |      support giving this type information for GraphLab Create to support
 |      writing to the database.
 |      
 |      To allow more expressive and accurate naming, `to_odbc` puts quotes
 |      around each identifier (table names and column names).  Depending on
 |      your database, you may need to refer to the created table with quote
 |      characters around the name.  This character is not the same for all
 |      databases, but '"' is the most common.
 |      
 |      Parameters
 |      ----------
 |      db :  `graphlab.extensions._odbc_connection.unity_odbc_connection`
 |        An ODBC connection object.  This can only be obtained by calling
 |        `graphlab.connect_odbc`.  Check that documentation for how to create
 |        this object.
 |      
 |      table_name : str
 |        The name of the table you would like to create/append to.
 |      
 |      append_if_exists : bool
 |        If True, this will attempt to append to the table named `table_name`
 |        if it is found to exist in the database.
 |      
 |      verbose : bool
 |        Print progress updates on the insertion process.
 |      
 |      Notes
 |      -----
 |      This functionality is only supported when using GraphLab Create
 |      entirely on your local machine.  Therefore, GraphLab Create's EC2 and
 |      Hadoop execution modes will not be able to use ODBC.  Note that this
 |      "local machine" rule does not apply to the machine your database is
 |      running on, which can (and often will) be running on a separate
 |      machine.
 |      
 |      Examples
 |      --------
 |      >>> db = graphlab.connect_odbc("DSN=my_awesome_dsn;UID=user;PWD=mypassword")
 |      
 |      >>> sf = graphlab.SFrame({'a':[1,2,3],'b':['hi','pika','bye']})
 |      
 |      >>> sf.to_odbc(db, 'a_cool_table')
 |  
 |  to_rdd(self, sc, number_of_partitions=4)
 |      Convert the current SFrame to the Spark RDD.
 |      
 |      Parameters
 |      ----------
 |      sc : SparkContext
 |          sc is an existing SparkContext.
 |      
 |      number_of_partitions: int
 |          number of partitions for the output rdd
 |      
 |      Returns
 |      ----------
 |      out: pyspark.rdd.RDD
 |      
 |      Notes
 |      ----------
 |      - Look at from_rdd().
 |      - Look at to_spark_dataframe().
 |      
 |      Examples
 |      --------
 |      
 |      >>> from pyspark import SparkContext
 |      >>> from graphlab import SFrame
 |      >>> sc = SparkContext('local')
 |      >>> sf = SFrame({'x': [1,2,3], 'y': ['fish', 'chips', 'salad']})
 |      >>> rdd = sf.to_rdd(sc)
 |      >>> rdd.collect()
 |      [{'x': 1L, 'y': 'fish'}, {'x': 2L, 'y': 'chips'}, {'x': 3L, 'y': 'salad'}]
 |  
 |  to_spark_dataframe(self, sc, sql, number_of_partitions=4)
 |      Convert the current SFrame to the Spark DataFrame.
 |      
 |      Parameters
 |      ----------
 |      sc : SparkContext
 |          sc is an existing SparkContext.
 |      
 |      sql : SQLContext
 |          sql is an existing SQLContext.
 |      
 |      number_of_partitions : int
 |          number of partitions for the output rdd
 |      
 |      Returns
 |      ----------
 |      out: pyspark.sql.DataFrame
 |      
 |      Notes
 |      -----
 |      - Look at to_rdd()
 |      - Look at from_rdd()
 |      
 |      Examples
 |      --------
 |      
 |      >>> from pyspark import SparkContext, SQLContext
 |      >>> from graphlab import SFrame
 |      >>> from pyspark.sql import SQLContext
 |      >>> sc = SparkContext('local')
 |      >>> sql = SQLContext(sc)
 |      >>> sf = SFrame({'x': [1,2,3], 'y': ['fish', 'chips', 'salad']})
 |      >>> df = sf.to_spark_dataframe(sc, sql)
 |      >>> df.show()
 |      x y
 |      1 fish
 |      2 chips
 |      3 salad
 |  
 |  topk(self, column_name, k=10, reverse=False)
 |      Get top k rows according to the given column. Result is according to and
 |      sorted by `column_name` in the given order (default is descending).
 |      When `k` is small, `topk` is more efficient than `sort`.
 |      
 |      Parameters
 |      ----------
 |      column_name : string
 |          The column to sort on
 |      
 |      k : int, optional
 |          The number of rows to return
 |      
 |      reverse : bool, optional
 |          If True, return the top k rows in ascending order, otherwise, in
 |          descending order.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          an SFrame containing the top k rows sorted by column_name.
 |      
 |      See Also
 |      --------
 |      sort
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id': range(1000)})
 |      >>> sf['value'] = -sf['id']
 |      >>> sf.topk('id', k=3)
 |      +--------+--------+
 |      |   id   |  value |
 |      +--------+--------+
 |      |   999  |  -999  |
 |      |   998  |  -998  |
 |      |   997  |  -997  |
 |      +--------+--------+
 |      [3 rows x 2 columns]
 |      
 |      >>> sf.topk('value', k=3)
 |      +--------+--------+
 |      |   id   |  value |
 |      +--------+--------+
 |      |   1    |  -1    |
 |      |   2    |  -2    |
 |      |   3    |  -3    |
 |      +--------+--------+
 |      [3 rows x 2 columns]
 |  
 |  unique(self)
 |      Remove duplicate rows of the SFrame. Will not necessarily preserve the
 |      order of the given SFrame in the new SFrame.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame that contains the unique rows of the current SFrame.
 |      
 |      Raises
 |      ------
 |      TypeError
 |        If any column in the SFrame is a dictionary type.
 |      
 |      See Also
 |      --------
 |      SArray.unique
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id':[1,2,3,3,4], 'value':[1,2,3,3,4]})
 |      >>> sf
 |      +----+-------+
 |      | id | value |
 |      +----+-------+
 |      | 1  |   1   |
 |      | 2  |   2   |
 |      | 3  |   3   |
 |      | 3  |   3   |
 |      | 4  |   4   |
 |      +----+-------+
 |      [5 rows x 2 columns]
 |      
 |      >>> sf.unique()
 |      +----+-------+
 |      | id | value |
 |      +----+-------+
 |      | 2  |   2   |
 |      | 4  |   4   |
 |      | 3  |   3   |
 |      | 1  |   1   |
 |      +----+-------+
 |      [4 rows x 2 columns]
 |  
 |  unpack(self, unpack_column, column_name_prefix=None, column_types=None, na_value=None, limit=None)
 |      Expand one column of this SFrame to multiple columns with each value in
 |      a separate column. Returns a new SFrame with the unpacked column
 |      replaced with a list of new columns.  The column must be of
 |      list/array/dict type.
 |      
 |      For more details regarding name generation, missing value handling and
 |      other, refer to the SArray version of
 |      :py:func:`~graphlab.SArray.unpack()`.
 |      
 |      Parameters
 |      ----------
 |      unpack_column : str
 |          Name of the unpacked column
 |      
 |      column_name_prefix : str, optional
 |          If provided, unpacked column names would start with the given
 |          prefix. If not provided, default value is the name of the unpacked
 |          column.
 |      
 |      column_types : [type], optional
 |          Column types for the unpacked columns.
 |          If not provided, column types are automatically inferred from first
 |          100 rows. For array type, default column types are float.  If
 |          provided, column_types also restricts how many columns to unpack.
 |      
 |      na_value : flexible_type, optional
 |          If provided, convert all values that are equal to "na_value" to
 |          missing value (None).
 |      
 |      limit : list[str] | list[int], optional
 |          Control unpacking only a subset of list/array/dict value. For
 |          dictionary SArray, `limit` is a list of dictionary keys to restrict.
 |          For list/array SArray, `limit` is a list of integers that are
 |          indexes into the list/array value.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame that contains rest of columns from original SFrame with
 |          the given column replaced with a collection of unpacked columns.
 |      
 |      See Also
 |      --------
 |      pack_columns, SArray.unpack
 |      
 |      Examples
 |      ---------
 |      >>> sf = graphlab.SFrame({'id': [1,2,3],
 |      ...                      'wc': [{'a': 1}, {'b': 2}, {'a': 1, 'b': 2}]})
 |      +----+------------------+
 |      | id |        wc        |
 |      +----+------------------+
 |      | 1  |     {'a': 1}     |
 |      | 2  |     {'b': 2}     |
 |      | 3  | {'a': 1, 'b': 2} |
 |      +----+------------------+
 |      [3 rows x 2 columns]
 |      
 |      >>> sf.unpack('wc')
 |      +----+------+------+
 |      | id | wc.a | wc.b |
 |      +----+------+------+
 |      | 1  |  1   | None |
 |      | 2  | None |  2   |
 |      | 3  |  1   |  2   |
 |      +----+------+------+
 |      [3 rows x 3 columns]
 |      
 |      To not have prefix in the generated column name:
 |      
 |      >>> sf.unpack('wc', column_name_prefix="")
 |      +----+------+------+
 |      | id |  a   |  b   |
 |      +----+------+------+
 |      | 1  |  1   | None |
 |      | 2  | None |  2   |
 |      | 3  |  1   |  2   |
 |      +----+------+------+
 |      [3 rows x 3 columns]
 |      
 |      To limit subset of keys to unpack:
 |      
 |      >>> sf.unpack('wc', limit=['b'])
 |      +----+------+
 |      | id | wc.b |
 |      +----+------+
 |      | 1  | None |
 |      | 2  |  2   |
 |      | 3  |  2   |
 |      +----+------+
 |      [3 rows x 3 columns]
 |      
 |      To unpack an array column:
 |      
 |      >>> sf = graphlab.SFrame({'id': [1,2,3],
 |      ...                       'friends': [array.array('d', [1.0, 2.0, 3.0]),
 |      ...                                   array.array('d', [2.0, 3.0, 4.0]),
 |      ...                                   array.array('d', [3.0, 4.0, 5.0])]})
 |      >>> sf
 |      +----+-----------------------------+
 |      | id |            friends          |
 |      +----+-----------------------------+
 |      | 1  | array('d', [1.0, 2.0, 3.0]) |
 |      | 2  | array('d', [2.0, 3.0, 4.0]) |
 |      | 3  | array('d', [3.0, 4.0, 5.0]) |
 |      +----+-----------------------------+
 |      [3 rows x 2 columns]
 |      
 |      >>> sf.unpack('friends')
 |      +----+-----------+-----------+-----------+
 |      | id | friends.0 | friends.1 | friends.2 |
 |      +----+-----------+-----------+-----------+
 |      | 1  |    1.0    |    2.0    |    3.0    |
 |      | 2  |    2.0    |    3.0    |    4.0    |
 |      | 3  |    3.0    |    4.0    |    5.0    |
 |      +----+-----------+-----------+-----------+
 |      [3 rows x 4 columns]
 |  
 |  unstack(self, column, new_column_name=None)
 |      Concatenate values from one or two columns into one column, grouping by
 |      all other columns. The resulting column could be of type list, array or
 |      dictionary.  If ``column`` is a numeric column, the result will be of
 |      array.array type.  If ``column`` is a non-numeric column, the new column
 |      will be of list type. If ``column`` is a list of two columns, the new
 |      column will be of dict type where the keys are taken from the first
 |      column in the list.
 |      
 |      Parameters
 |      ----------
 |      column : str | [str, str]
 |          The column(s) that is(are) to be concatenated.
 |          If str, then collapsed column type is either array or list.
 |          If [str, str], then collapsed column type is dict
 |      
 |      new_column_name : str, optional
 |          New column name. If not given, a name is generated automatically.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |          A new SFrame containing the grouped columns as well as the new
 |          column.
 |      
 |      See Also
 |      --------
 |      stack : The inverse of unstack.
 |      
 |      groupby : ``unstack`` is a special version of ``groupby`` that uses the
 |        :mod:`~graphlab.aggregate.CONCAT` aggregator
 |      
 |      Notes
 |      -----
 |      - There is no guarantee the resulting SFrame maintains the same order as
 |        the original SFrame.
 |      
 |      - Missing values are maintained during unstack.
 |      
 |      - When unstacking into a dictionary, if there is more than one instance
 |        of a given key for a particular group, an arbitrary value is selected.
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'count':[4, 2, 1, 1, 2, None],
 |      ...                       'topic':['cat', 'cat', 'dog', 'elephant', 'elephant', 'fish'],
 |      ...                       'word':['a', 'c', 'c', 'a', 'b', None]})
 |      >>> sf.unstack(column=['word', 'count'], new_column_name='words')
 |      +----------+------------------+
 |      |  topic   |      words       |
 |      +----------+------------------+
 |      | elephant | {'a': 1, 'b': 2} |
 |      |   dog    |     {'c': 1}     |
 |      |   cat    | {'a': 4, 'c': 2} |
 |      |   fish   |       None       |
 |      +----------+------------------+
 |      [4 rows x 2 columns]
 |      
 |      >>> sf = graphlab.SFrame({'friend': [2, 3, 4, 5, 6, 4, 5, 2, 3],
 |      ...                      'user': [1, 1, 1, 2, 2, 2, 3, 4, 4]})
 |      >>> sf.unstack('friend', new_column_name='friends')
 |      +------+-----------------------------+
 |      | user |           friends           |
 |      +------+-----------------------------+
 |      |  3   |      array('d', [5.0])      |
 |      |  1   | array('d', [2.0, 4.0, 3.0]) |
 |      |  2   | array('d', [5.0, 6.0, 4.0]) |
 |      |  4   |    array('d', [2.0, 3.0])   |
 |      +------+-----------------------------+
 |      [4 rows x 2 columns]
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  __get_staging_dir__(cls, cur_sc, graphlab_util_ref) from __builtin__.type
 |  
 |  from_odbc(cls, db, sql, verbose=False) from __builtin__.type
 |      Convert a table or query from a database to an SFrame.
 |      
 |      This function does not do any checking on the given SQL query, and
 |      cannot know what effect it will have on the database.  Any side effects
 |      from the query will be reflected on the database.  If no result
 |      rows are returned, an empty SFrame is created.
 |      
 |      Keep in mind the default case your database stores table names in.  In
 |      some cases, you may need to add quotation marks (or whatever character
 |      your database uses to quote identifiers), especially if you created the
 |      table using `to_odbc`.
 |      
 |      Parameters
 |      ----------
 |      db :  `graphlab.extensions._odbc_connection.unity_odbc_connection`
 |        An ODBC connection object.  This can only be obtained by calling
 |        `graphlab.connect_odbc`.  Check that documentation for how to create
 |        this object.
 |      
 |      sql : str
 |        A SQL query.  The query must be acceptable by the ODBC driver used by
 |        `graphlab.extensions._odbc_connection.unity_odbc_connection`.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |      
 |      Notes
 |      -----
 |      This functionality is only supported when using GraphLab Create
 |      entirely on your local machine.  Therefore, GraphLab Create's EC2 and
 |      Hadoop execution modes will not be able to use ODBC.  Note that this
 |      does not apply to the machine your database is running, which can (and
 |      often will) be running on a separate machine.
 |      
 |      Examples
 |      --------
 |      >>> db = graphlab.connect_odbc("DSN=my_awesome_dsn;UID=user;PWD=mypassword")
 |      
 |      >>> a_table = graphlab.SFrame.from_odbc(db, "SELECT * FROM a_table")
 |      
 |      >>> join_result = graphlab.SFrame.from_odbc(db, 'SELECT * FROM "MyTable" a, "AnotherTable" b WHERE a.id=b.id')
 |  
 |  from_rdd(cls, rdd, cur_sc) from __builtin__.type
 |      Convert a Spark RDD into an SFrame.
 |      
 |      Parameters
 |      ----------
 |      rdd : pyspark.rdd.RDD or pyspark.sql.DataFrame
 |          The input Spark RDD that is going to be converted to an SFrame.
 |      cur_sc : SparkContext
 |          An instance object of an SparkContext.
 |      
 |      Returns
 |      -------
 |      out : SFrame
 |      
 |      Notes
 |      ----------
 |      - look at to_rdd().
 |      - look at to_spark_dataframe().
 |      
 |      Examples
 |      --------
 |      
 |      >>> from pyspark import SparkContext
 |      >>> from graphlab import SFrame
 |      >>> sc = SparkContext('local')
 |      >>> rdd = sc.parallelize([1,2,3])
 |      >>> sf = SFrame.from_rdd(rdd, sc)
 |      >>> sf
 |      Data:
 |      +-----+
 |      |  X1 |
 |      +-----+
 |      | 1.0 |
 |      | 2.0 |
 |      | 3.0 |
 |      +-----+
 |      [3 rows x 1 columns]
 |  
 |  read_csv(cls, url, delimiter=',', header=True, error_bad_lines=False, comment_char='', escape_char=r'\', double_quote=True, quote_char='"', skip_initial_space=True, column_type_hints=None, na_values=['NA'], line_terminator='\n', usecols=[], nrows=None, skiprows=0, verbose=True, **kwargs) from __builtin__.type
 |              Constructs an SFrame from a CSV file or a path to multiple CSVs.
 |      
 |              Parameters
 |              ----------
 |              url : string
 |                  Location of the CSV file or directory to load. If URL is a directory
 |                  or a "glob" pattern, all matching files will be loaded.
 |      
 |              delimiter : string, optional
 |                  This describes the delimiter used for parsing csv files.
 |      
 |              header : bool, optional
 |                  If true, uses the first row as the column names. Otherwise use the
 |                  default column names : 'X1, X2, ...'.
 |      
 |              error_bad_lines : bool
 |                  If true, will fail upon encountering a bad line. If false, will
 |                  continue parsing skipping lines which fail to parse correctly.
 |                  A sample of the first 10 encountered bad lines will be printed.
 |      
 |              comment_char : string, optional
 |                  The character which denotes that the remainder of the line is a
 |                  comment.
 |      
 |              escape_char : string, optional
 |                  Character which begins a C escape sequence
 |      
 |              double_quote : bool, optional
 |                  If True, two consecutive quotes in a string are parsed to a single
 |                  quote.
 |      
 |              quote_char : string, optional
 |                  Character sequence that indicates a quote.
 |      
 |              skip_initial_space : bool, optional
 |                  Ignore extra spaces at the start of a field
 |      
 |              column_type_hints : None, type, list[type], dict[string, type], optional
 |                  This provides type hints for each column. By default, this method
 |                  attempts to detect the type of each column automatically.
 |      
 |                  Supported types are int, float, str, list, dict, and array.array.
 |      
 |                  * If a single type is provided, the type will be
 |                    applied to all columns. For instance, column_type_hints=float
 |                    will force all columns to be parsed as float.
 |                  * If a list of types is provided, the types applies
 |                    to each column in order, e.g.[int, float, str]
 |                    will parse the first column as int, second as float and third as
 |                    string.
 |                  * If a dictionary of column name to type is provided,
 |                    each type value in the dictionary is applied to the key it
 |                    belongs to.
 |                    For instance {'user':int} will hint that the column called "user"
 |                    should be parsed as an integer, and the rest will be type inferred.
 |      
 |              na_values : str | list of str, optional
 |                  A string or list of strings to be interpreted as missing values.
 |      
 |              line_terminator : str, optional
 |                  A string to be interpreted as the line terminator. Defaults to "
 |      "
 |                  which will also correctly match Mac, Linux and Windows line endings
", "
 |      " and "
 |      " respectively)
 |      
 |              usecols : list of str, optional
 |                  A subset of column names to output. If unspecified (default),
 |                  all columns will be read. This can provide performance gains if the
 |                  number of columns are large. If the input file has no headers,
 |                  usecols=['X1','X3'] will read columns 1 and 3.
 |      
 |              nrows : int, optional
 |                  If set, only this many rows will be read from the file.
 |      
 |              skiprows : int, optional
 |                  If set, this number of rows at the start of the file are skipped.
 |      
 |              verbose : bool, optional
 |                  If True, print the progress.
 |      
 |              Returns
 |              -------
 |              out : SFrame
 |      
 |              See Also
 |              --------
 |              read_csv_with_errors, SFrame
 |      
 |              Examples
 |              --------
 |      
 |              Read a regular csv file, with all default options, automatically
 |              determine types:
 |      
 |              >>> url = 'http://s3.amazonaws.com/gl-testdata/rating_data_example.csv'
 |              >>> sf = graphlab.SFrame.read_csv(url)
 |              >>> sf
 |              Columns:
 |                user_id int
 |                movie_id  int
 |                rating  int
 |              Rows: 10000
 |              +---------+----------+--------+
 |              | user_id | movie_id | rating |
 |              +---------+----------+--------+
 |              |  25904  |   1663   |   3    |
 |              |  25907  |   1663   |   3    |
 |              |  25923  |   1663   |   3    |
 |              |  25924  |   1663   |   3    |
 |              |  25928  |   1663   |   2    |
 |              |   ...   |   ...    |  ...   |
 |              +---------+----------+--------+
 |              [10000 rows x 3 columns]
 |      
 |              Read only the first 100 lines of the csv file:
 |      
 |              >>> sf = graphlab.SFrame.read_csv(url, nrows=100)
 |              >>> sf
 |              Columns:
 |                user_id int
 |                movie_id  int
 |                rating  int
 |              Rows: 100
 |              +---------+----------+--------+
 |              | user_id | movie_id | rating |
 |              +---------+----------+--------+
 |              |  25904  |   1663   |   3    |
 |              |  25907  |   1663   |   3    |
 |              |  25923  |   1663   |   3    |
 |              |  25924  |   1663   |   3    |
 |              |  25928  |   1663   |   2    |
 |              |   ...   |   ...    |  ...   |
 |              +---------+----------+--------+
 |              [100 rows x 3 columns]
 |      
 |              Read all columns as str type
 |      
 |              >>> sf = graphlab.SFrame.read_csv(url, column_type_hints=str)
 |              >>> sf
 |              Columns:
 |                user_id  str
 |                movie_id  str
 |                rating  str
 |              Rows: 10000
 |              +---------+----------+--------+
 |              | user_id | movie_id | rating |
 |              +---------+----------+--------+
 |              |  25904  |   1663   |   3    |
 |              |  25907  |   1663   |   3    |
 |              |  25923  |   1663   |   3    |
 |              |  25924  |   1663   |   3    |
 |              |  25928  |   1663   |   2    |
 |              |   ...   |   ...    |  ...   |
 |              +---------+----------+--------+
 |              [10000 rows x 3 columns]
 |      
 |              Specify types for a subset of columns and leave the rest to be str.
 |      
 |              >>> sf = graphlab.SFrame.read_csv(url,
 |              ...                               column_type_hints={
 |              ...                               'user_id':int, 'rating':float
 |              ...                               })
 |              >>> sf
 |              Columns:
 |                user_id str
 |                movie_id  str
 |                rating  float
 |              Rows: 10000
 |              +---------+----------+--------+
 |              | user_id | movie_id | rating |
 |              +---------+----------+--------+
 |              |  25904  |   1663   |  3.0   |
 |              |  25907  |   1663   |  3.0   |
 |              |  25923  |   1663   |  3.0   |
 |              |  25924  |   1663   |  3.0   |
 |              |  25928  |   1663   |  2.0   |
 |              |   ...   |   ...    |  ...   |
 |              +---------+----------+--------+
 |              [10000 rows x 3 columns]
 |      
 |              Not treat first line as header:
 |      
 |              >>> sf = graphlab.SFrame.read_csv(url, header=False)
 |              >>> sf
 |              Columns:
 |                X1  str
 |                X2  str
 |                X3  str
 |              Rows: 10001
 |              +---------+----------+--------+
 |              |    X1   |    X2    |   X3   |
 |              +---------+----------+--------+
 |              | user_id | movie_id | rating |
 |              |  25904  |   1663   |   3    |
 |              |  25907  |   1663   |   3    |
 |              |  25923  |   1663   |   3    |
 |              |  25924  |   1663   |   3    |
 |              |  25928  |   1663   |   2    |
 |              |   ...   |   ...    |  ...   |
 |              +---------+----------+--------+
 |              [10001 rows x 3 columns]
 |      
 |              Treat '3' as missing value:
 |      
 |              >>> sf = graphlab.SFrame.read_csv(url, na_values=['3'], column_type_hints=str)
 |              >>> sf
 |              Columns:
 |                user_id str
 |                movie_id  str
 |                rating  str
 |              Rows: 10000
 |              +---------+----------+--------+
 |              | user_id | movie_id | rating |
 |              +---------+----------+--------+
 |              |  25904  |   1663   |  None  |
 |              |  25907  |   1663   |  None  |
 |              |  25923  |   1663   |  None  |
 |              |  25924  |   1663   |  None  |
 |              |  25928  |   1663   |   2    |
 |              |   ...   |   ...    |  ...   |
 |              +---------+----------+--------+
 |              [10000 rows x 3 columns]
 |      
 |              Throw error on parse failure:
 |      
 |              >>> bad_url = 'https://s3.amazonaws.com/gl-testdata/bad_csv_example.csv'
 |              >>> sf = graphlab.SFrame.read_csv(bad_url, error_bad_lines=True)
 |              RuntimeError: Runtime Exception. Unable to parse line "x,y,z,a,b,c"
 |              Set error_bad_lines=False to skip bad lines
 |  
 |  read_csv_with_errors(cls, url, delimiter=',', header=True, comment_char='', escape_char=r'\', double_quote=True, quote_char='"', skip_initial_space=True, column_type_hints=None, na_values=['NA'], line_terminator='\n', usecols=[], nrows=None, skiprows=0, verbose=True, **kwargs) from __builtin__.type
 |              Constructs an SFrame from a CSV file or a path to multiple CSVs, and
 |              returns a pair containing the SFrame and a dict of filenames to SArrays
 |              indicating for each file, what are the incorrectly parsed lines
 |              encountered.
 |      
 |              Parameters
 |              ----------
 |              url : string
 |                  Location of the CSV file or directory to load. If URL is a directory
 |                  or a "glob" pattern, all matching files will be loaded.
 |      
 |              delimiter : string, optional
 |                  This describes the delimiter used for parsing csv files.
 |      
 |              header : bool, optional
 |                  If true, uses the first row as the column names. Otherwise use the
 |                  default column names: 'X1, X2, ...'.
 |      
 |              comment_char : string, optional
 |                  The character which denotes that the
 |                  remainder of the line is a comment.
 |      
 |              escape_char : string, optional
 |                  Character which begins a C escape sequence
 |      
 |              double_quote : bool, optional
 |                  If True, two consecutive quotes in a string are parsed to a single
 |                  quote.
 |      
 |              quote_char : string, optional
 |                  Character sequence that indicates a quote.
 |      
 |              skip_initial_space : bool, optional
 |                  Ignore extra spaces at the start of a field
 |      
 |              column_type_hints : None, type, list[type], dict[string, type], optional
 |                  This provides type hints for each column. By default, this method
 |                  attempts to detect the type of each column automatically.
 |      
 |                  Supported types are int, float, str, list, dict, and array.array.
 |      
 |                  * If a single type is provided, the type will be
 |                    applied to all columns. For instance, column_type_hints=float
 |                    will force all columns to be parsed as float.
 |                  * If a list of types is provided, the types applies
 |                    to each column in order, e.g.[int, float, str]
 |                    will parse the first column as int, second as float and third as
 |                    string.
 |                  * If a dictionary of column name to type is provided,
 |                    each type value in the dictionary is applied to the key it
 |                    belongs to.
 |                    For instance {'user':int} will hint that the column called "user"
 |                    should be parsed as an integer, and the rest will be type inferred.
 |      
 |              na_values : str | list of str, optional
 |                  A string or list of strings to be interpreted as missing values.
 |      
 |              line_terminator : str, optional
 |                  A string to be interpreted as the line terminator. Defaults to "
 |      "
 |                  which will also correctly match Mac, Linux and Windows line endings
", "
 |      " and "
 |      " respectively)
 |      
 |              usecols : list of str, optional
 |                  A subset of column names to output. If unspecified (default),
 |                  all columns will be read. This can provide performance gains if the
 |                  number of columns are large. If the input file has no headers,
 |                  usecols=['X1','X3'] will read columns 1 and 3.
 |      
 |              nrows : int, optional
 |                  If set, only this many rows will be read from the file.
 |      
 |              skiprows : int, optional
 |                  If set, this number of rows at the start of the file are skipped.
 |      
 |              verbose : bool, optional
 |                  If True, print the progress.
 |      
 |              Returns
 |              -------
 |              out : tuple
 |                  The first element is the SFrame with good data. The second element
 |                  is a dictionary of filenames to SArrays indicating for each file,
 |                  what are the incorrectly parsed lines encountered.
 |      
 |              See Also
 |              --------
 |              read_csv, SFrame
 |      
 |              Examples
 |              --------
 |              >>> bad_url = 'https://s3.amazonaws.com/gl-testdata/bad_csv_example.csv'
 |              >>> (sf, bad_lines) = graphlab.SFrame.read_csv_with_errors(bad_url)
 |              >>> sf
 |              +---------+----------+--------+
 |              | user_id | movie_id | rating |
 |              +---------+----------+--------+
 |              |  25904  |   1663   |   3    |
 |              |  25907  |   1663   |   3    |
 |              |  25923  |   1663   |   3    |
 |              |  25924  |   1663   |   3    |
 |              |  25928  |   1663   |   2    |
 |              |   ...   |   ...    |  ...   |
 |              +---------+----------+--------+
 |              [98 rows x 3 columns]
 |      
 |              >>> bad_lines
 |              {'https://s3.amazonaws.com/gl-testdata/bad_csv_example.csv': dtype: str
 |               Rows: 1
 |               ['x,y,z,a,b,c']}
 |  
 |  read_json(cls, url, orient='records') from __builtin__.type
 |      Reads a JSON file representing a table into an SFrame.
 |      
 |      Parameters
 |      ----------
 |      url : string
 |          Location of the CSV file or directory to load. If URL is a directory
 |          or a "glob" pattern, all matching files will be loaded.
 |      
 |      orient : string, optional. Either "records" or "lines"
 |          If orient="records" the file is expected to contain a single JSON
 |          array, where each array element is a dictionary. If orient="lines",
 |          the file is expected to contain a JSON element per line.
 |      
 |      Examples
 |      --------
 |      The orient parameter describes the expected input format of the JSON
 |      file.
 |      
 |      If orient="records", the JSON file is expected to contain a single
 |      JSON Array where each array element is a dictionary describing the row.
 |      For instance:
 |      
 |      >>> !cat input.json
 |      [{'a':1,'b':1}, {'a':2,'b':2}, {'a':3,'b':3}]
 |      >>> SFrame.read_json('input.json', orient='records')
 |      Columns:
 |              a       int
 |              b       int
 |      Rows: 3
 |      Data:
 |      +---+---+
 |      | a | b |
 |      +---+---+
 |      | 1 | 1 |
 |      | 2 | 2 |
 |      | 3 | 3 |
 |      +---+---+
 |      
 |      If orient="lines", the JSON file is expected to contain a JSON element
 |      per line. If each line contains a dictionary, it is automatically
 |      unpacked.
 |      
 |      >>> !cat input.json
 |      {'a':1,'b':1}
 |      {'a':2,'b':2}
 |      {'a':3,'b':3}
 |      >>> g = SFrame.read_json('input.json', orient='lines')
 |      Columns:
 |              a       int
 |              b       int
 |      Rows: 3
 |      Data:
 |      +---+---+
 |      | a | b |
 |      +---+---+
 |      | 1 | 1 |
 |      | 2 | 2 |
 |      | 3 | 3 |
 |      +---+---+
 |      
 |      If the lines are not dictionaries, the original format is maintained.
 |      
 |      >>> !cat input.json
 |      ['a','b','c']
 |      ['d','e','f']
 |      ['g','h','i']
 |      [1,2,3]
 |      >>> g = SFrame.read_json('input.json', orient='lines')
 |      Columns:
 |              X1      list
 |      Rows: 3
 |      Data:
 |      +-----------+
 |      |     X1    |
 |      +-----------+
 |      | [a, b, c] |
 |      | [d, e, f] |
 |      | [g, h, i] |
 |      +-----------+
 |      [3 rows x 1 columns]
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __proxy__
 |  
 |  shape
 |      The shape of the SFrame, in a tuple. The first entry is the number of
 |      rows, the second is the number of columns.
 |      
 |      Examples
 |      --------
 |      >>> sf = graphlab.SFrame({'id':[1,2,3], 'val':['A','B','C']})
 |      >>> sf.shape
 |      (3, 2)
